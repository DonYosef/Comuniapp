import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

import { PrismaService } from '../prisma/prisma.service';

import { ChatbotResponseDto } from './dto/chatbot.dto';

@Injectable()
export class ChatbotService {
  private readonly logger = new Logger(ChatbotService.name);
  private readonly OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';

  // Cache para respuestas frecuentes y control de rate limiting inteligente
  private responseCache = new Map<string, { answer: string; timestamp: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutos

  // Control inteligente de rate limiting para OpenAI
  private lastRequestTime: number = 0;
  private readonly MIN_DELAY_BETWEEN_REQUESTS = 1000; // 1 segundo m√≠nimo entre requests

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
  ) {
    // Verificar configuraci√≥n de OpenAI al inicializar
    this.verifyOpenAIConfiguration().then((isConfigured) => {
      if (isConfigured) {
        this.logger.log('üöÄ Chatbot service initialized with OpenAI');
      } else {
        this.logger.warn('‚ö†Ô∏è Chatbot service initialized but OpenAI not configured');
      }
    });
  }

  async processQuestion(question: string): Promise<ChatbotResponseDto> {
    const lowerQuestion = question.toLowerCase().trim();

    if (!question) {
      return { answer: 'Por favor ingresa una pregunta.' };
    }

    // --- 0) RESPUESTAS R√ÅPIDAS (SALUDOS Y COMANDOS B√ÅSICOS) ---
    const quickResponse = this.getQuickResponse(lowerQuestion);
    if (quickResponse) {
      return { answer: quickResponse };
    }

    // --- 1) ESPACIOS COMUNES ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'espacios comunes',
        'espacios',
        'salon',
        'gym',
        'piscina',
        'cancha',
        'jardin',
        'terraza',
      ])
    ) {
      return await this.getCommonSpacesInfo();
    }

    // --- 2) AVISOS COMUNITARIOS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'avisos',
        'comunicados',
        'noticias',
        'anuncios',
        'informacion',
      ])
    ) {
      return await this.getCommunityAnnouncements();
    }

    // --- 3) GASTOS COMUNES ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'gastos comunes',
        'gastos',
        'cuotas',
        'pagos',
        'facturas',
        'cobros',
        'administracion',
      ])
    ) {
      return await this.getCommonExpensesInfo();
    }

    // --- 3.1) CONSULTAS ESPEC√çFICAS SOBRE DEUDAS (P√öBLICO) ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'plata',
        'dinero',
        'debo',
        'deuda',
        'deudas',
        'pendiente',
        'pendientes',
        'adeudo',
        'adeudos',
        'cuanto debo',
        'cuanta plata',
        'cuanto dinero',
        'monto',
        'montos',
        'cuanto tengo que pagar',
        'cuanto debo pagar',
        'estado de pagos',
        'mis pagos',
      ])
    ) {
      return {
        answer:
          'üí∞ Consulta sobre Deudas\n\n‚ùå Para consultar tus gastos pendientes, necesitas estar autenticado.\n\nüí° *Inicia sesi√≥n para ver el estado de tus pagos espec√≠ficos.*',
      };
    }

    // --- 4) RESIDENTES ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'residentes',
        'residente',
        'vecinos',
        'habitantes',
        'propietarios',
      ])
    ) {
      return await this.getResidentsInfo();
    }

    // --- 5) VISITANTES ---
    if (
      this.matchesKeywords(lowerQuestion, ['visitantes', 'visitas', 'invitados', 'acompanantes'])
    ) {
      return await this.getVisitorsInfo();
    }

    // --- 6) ENCOMIENDAS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'encomiendas',
        'paquetes',
        'correo',
        'delivery',
        'envios',
        'recepcion',
      ])
    ) {
      return await this.getParcelsInfo();
    }

    // --- 7) INGRESOS COMUNITARIOS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'ingresos',
        'rentas',
        'alquileres',
        'ventas',
        'finanzas',
      ])
    ) {
      return await this.getCommunityIncomeInfo();
    }

    // --- 8) CATEGOR√çAS DE GASTOS ---
    if (this.matchesKeywords(lowerQuestion, ['categorias', 'tipos de gastos', 'clasificacion'])) {
      return await this.getExpenseCategoriesInfo();
    }

    // --- 9) UNIDADES Y APARTAMENTOS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'unidades',
        'apartamentos',
        'departamentos',
        'pisos',
        'torres',
      ])
    ) {
      return await this.getUnitsInfo();
    }

    // --- 10) CONSULTA AL MODELO DE OPENAI ---
    return await this.queryOpenAI(question);
  }

  async processQuestionWithUserContext(question: string, user: any): Promise<ChatbotResponseDto> {
    const lowerQuestion = question.toLowerCase().trim();

    if (!question) {
      return { answer: 'Por favor ingresa una pregunta.' };
    }

    // --- 0) RESPUESTAS R√ÅPIDAS (SALUDOS Y COMANDOS B√ÅSICOS) ---
    const quickResponse = this.getQuickResponseWithUserContext(lowerQuestion, user);
    if (quickResponse) {
      return { answer: quickResponse };
    }

    // Obtener informaci√≥n del usuario y sus roles
    const userInfo = await this.getUserContextInfo(user);
    const userRoles = user.roles?.map((role: any) => role.name || role.role?.name) || [];

    // Determinar el tipo de usuario principal
    const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
    const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
    const isConcierge = userRoles.includes('CONCIERGE');
    const isResident = userRoles.includes('RESIDENT');

    // --- 0.5) DETECCI√ìN DE PREGUNTAS SOBRE "C√ìMO USAR" FUNCIONALIDADES ---
    // Si el usuario pregunta c√≥mo usar algo, explicamos sin consultar BD
    // Si pregunta directamente por datos (mu√©strame, quiero ver), consultamos BD
    const isHowToQuestion = this.isHowToQuestion(lowerQuestion);
    const isDataRequest = this.isDataRequest(lowerQuestion);

    // Si es pregunta de "c√≥mo usar" y NO es pregunta directa de datos, dar explicaci√≥n
    if (isHowToQuestion && !isDataRequest) {
      const functionality = this.detectFunctionalityFromQuestion(lowerQuestion);
      if (functionality) {
        const explanation = await this.getHowToExplanation(functionality, userInfo, userRoles);
        if (explanation) {
          return explanation;
        }
        // Si no hay explicaci√≥n espec√≠fica, contin√∫a con el flujo normal
      }
    }

    // --- 1) ESPACIOS COMUNES ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'espacios comunes',
        'espacios',
        'salon',
        'gym',
        'piscina',
        'cancha',
        'jardin',
        'terraza',
      ])
    ) {
      return await this.getCommonSpacesInfoForUser(userInfo, userRoles);
    }

    // --- 2) AVISOS COMUNITARIOS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'avisos',
        'comunicados',
        'noticias',
        'anuncios',
        'informacion',
      ])
    ) {
      return await this.getCommunityAnnouncementsForUser(userInfo, userRoles);
    }

    // --- 3) GASTOS COMUNES ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'gastos comunes',
        'gastos',
        'cuotas',
        'pagos',
        'facturas',
        'cobros',
        'administracion',
      ])
    ) {
      return await this.getCommonExpensesInfoForUser(userInfo, userRoles);
    }

    // --- 3.1) CONSULTAS ESPEC√çFICAS SOBRE DEUDAS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'plata',
        'dinero',
        'debo',
        'deuda',
        'deudas',
        'pendiente',
        'pendientes',
        'adeudo',
        'adeudos',
        'cuanto debo',
        'cuanta plata',
        'cuanto dinero',
        'monto',
        'montos',
        'cuanto tengo que pagar',
        'cuanto debo pagar',
        'estado de pagos',
        'mis pagos',
      ])
    ) {
      return await this.getDebtInfoForUser(userInfo, userRoles);
    }

    // --- 4) RESIDENTES ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'residentes',
        'residente',
        'vecinos',
        'habitantes',
        'propietarios',
      ])
    ) {
      return await this.getResidentsInfoForUser(userInfo, userRoles);
    }

    // --- 5) VISITANTES ---
    if (
      this.matchesKeywords(lowerQuestion, ['visitantes', 'visitas', 'invitados', 'acompanantes'])
    ) {
      return await this.getVisitorsInfoForUser(userInfo, userRoles);
    }

    // --- 6) ENCOMIENDAS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'encomiendas',
        'paquetes',
        'correo',
        'delivery',
        'envios',
        'recepcion',
      ])
    ) {
      return await this.getParcelsInfoForUser(userInfo, userRoles);
    }

    // --- 7) INGRESOS COMUNITARIOS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'ingresos',
        'rentas',
        'alquileres',
        'ventas',
        'finanzas',
      ])
    ) {
      return await this.getCommunityIncomeInfoForUser(userInfo, userRoles);
    }

    // --- 8) CATEGOR√çAS DE GASTOS ---
    if (this.matchesKeywords(lowerQuestion, ['categorias', 'tipos de gastos', 'clasificacion'])) {
      return await this.getExpenseCategoriesInfoForUser(userInfo, userRoles);
    }

    // --- 9) UNIDADES Y APARTAMENTOS ---
    if (
      this.matchesKeywords(lowerQuestion, [
        'unidades',
        'apartamentos',
        'departamentos',
        'pisos',
        'torres',
      ])
    ) {
      return await this.getUnitsInfoForUser(userInfo, userRoles);
    }

    // --- 10) CONSULTA AL MODELO DE OPENAI CON CONTEXTO DE USUARIO ---
    return await this.queryOpenAIWithUserContext(question, userInfo, userRoles);
  }

  // M√©todo auxiliar para verificar si una pregunta coincide con palabras clave
  private matchesKeywords(question: string, keywords: string[]): boolean {
    return keywords.some((keyword) => question.includes(keyword));
  }

  /**
   * Detecta si la pregunta es sobre "c√≥mo usar" o "c√≥mo hacer" algo (explicaci√≥n)
   * vs una solicitud directa de datos
   */
  private isHowToQuestion(question: string): boolean {
    const howToKeywords = [
      'como',
      'c√≥mo',
      'como puedo',
      'c√≥mo puedo',
      'como hacer',
      'c√≥mo hacer',
      'explicame',
      'expl√≠came',
      'explicar',
      'explica',
      'como funciona',
      'c√≥mo funciona',
      'como se',
      'c√≥mo se',
      'pasos para',
      'paso a paso',
      'tutorial',
      'instrucciones',
      'ayuda con',
      'como usar',
      'c√≥mo usar',
      'como debo',
      'c√≥mo debo',
      'que tengo que hacer',
      'qu√© tengo que hacer',
      'proceso para',
      'gu√≠a',
      'manual',
    ];
    return howToKeywords.some((keyword) => question.includes(keyword));
  }

  /**
   * Detecta si la pregunta es una solicitud directa de datos (no explicaci√≥n)
   */
  private isDataRequest(question: string): boolean {
    const dataRequestKeywords = [
      'muestrame',
      'mu√©strame',
      'muestra',
      'quiero ver',
      'dame',
      'dame los',
      'dame las',
      'ver los',
      'ver las',
      'ver mis',
      'ver mis',
      'cu√°les son',
      'cuales son',
      'tengo',
      'hay',
      'existen',
      'lista',
      'listado',
      'listar',
      'consulta',
      'consultar',
      'obtener',
      'traer',
      'mostrar los',
      'mostrar las',
      'mostrar mis',
      'datos de',
      'informaci√≥n de',
      'estado de',
    ];
    return dataRequestKeywords.some((keyword) => question.includes(keyword));
  }

  /**
   * Detecta qu√© funcionalidad se est√° preguntando desde la pregunta
   */
  private detectFunctionalityFromQuestion(question: string): string | null {
    const lowerQuestion = question.toLowerCase();

    // Espacios comunes
    if (
      this.matchesKeywords(lowerQuestion, [
        'espacios comunes',
        'espacios',
        'salon',
        'sal√≥n',
        'gimnasio',
        'gym',
        'piscina',
        'cancha',
        'jardin',
        'jard√≠n',
        'terraza',
        'reserva',
        'reservas',
      ])
    ) {
      return 'espacios_comunes';
    }

    // Avisos
    if (
      this.matchesKeywords(lowerQuestion, [
        'avisos',
        'aviso',
        'comunicados',
        'comunicado',
        'anuncios',
        'anuncio',
        'noticias',
        'noticia',
      ])
    ) {
      return 'avisos';
    }

    // Gastos comunes
    if (
      this.matchesKeywords(lowerQuestion, [
        'gastos comunes',
        'gastos',
        'gasto',
        'pagos',
        'pago',
        'cuotas',
        'cuota',
        'facturas',
        'factura',
        'deudas',
        'deuda',
      ])
    ) {
      return 'gastos_comunes';
    }

    // Visitantes
    if (
      this.matchesKeywords(lowerQuestion, [
        'visitantes',
        'visitante',
        'visitas',
        'visita',
        'invitados',
        'invitado',
      ])
    ) {
      return 'visitantes';
    }

    // Encomiendas
    if (
      this.matchesKeywords(lowerQuestion, [
        'encomiendas',
        'encomienda',
        'paquetes',
        'paquete',
        'env√≠os',
        'envios',
        'envio',
      ])
    ) {
      return 'encomiendas';
    }

    // Reservas
    if (
      this.matchesKeywords(lowerQuestion, [
        'reservas',
        'reserva',
        'reservar',
        'calendario',
        'agenda',
      ])
    ) {
      return 'reservas';
    }

    // Residentes
    if (
      this.matchesKeywords(lowerQuestion, [
        'residentes',
        'residente',
        'vecinos',
        'vecino',
        'habitantes',
        'habitante',
        'propietarios',
        'propietario',
      ])
    ) {
      return 'residentes';
    }

    // Incidencias
    if (
      this.matchesKeywords(lowerQuestion, [
        'incidencias',
        'incidencia',
        'problemas',
        'problema',
        'reportar',
        'reporte',
      ])
    ) {
      return 'incidencias';
    }

    // Ingresos (solo admins)
    if (
      this.matchesKeywords(lowerQuestion, [
        'ingresos',
        'ingreso',
        'rentas',
        'renta',
        'alquileres',
        'alquiler',
      ])
    ) {
      return 'ingresos';
    }

    // Organizaciones (solo super admin)
    if (this.matchesKeywords(lowerQuestion, ['organizaciones', 'organizaci√≥n', 'organizacion'])) {
      return 'organizaciones';
    }

    // M√©tricas (solo super admin)
    if (
      this.matchesKeywords(lowerQuestion, [
        'metricas',
        'm√©tricas',
        'estadisticas',
        'estad√≠sticas',
        'reportes',
        'reporte',
      ])
    ) {
      return 'metricas';
    }

    return null;
  }

  /**
   * Proporciona explicaciones sobre c√≥mo usar funcionalidades seg√∫n el rol del usuario
   */
  private async getHowToExplanation(
    functionality: string,
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto | null> {
    const userName = userInfo?.name || 'Usuario';
    const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
    const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
    const isConcierge = userRoles.includes('CONCIERGE');
    const isResident =
      userRoles.includes('RESIDENT') || userRoles.includes('OWNER') || userRoles.includes('TENANT');

    switch (functionality) {
      case 'espacios_comunes':
        if (isSuperAdmin) {
          return {
            answer: `üè¢ **C√≥mo gestionar Espacios Comunes - Super Administrador**

Como Super Administrador, puedes crear, registrar y gestionar espacios comunes de todas las comunidades del sistema.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver todos los espacios comunes del sistema
‚Ä¢ Crear/Registrar nuevos espacios comunes en cualquier comunidad
‚Ä¢ Editar y eliminar espacios comunes existentes
‚Ä¢ Gestionar horarios y disponibilidad de espacios
‚Ä¢ Ver todas las reservas de espacios comunes
‚Ä¢ Configurar caracter√≠sticas de cada espacio

**üéØ Pasos para crear/registrar un espacio com√∫n:**
1. Desde el panel: **Super Administraci√≥n ‚Üí Espacios Comunes ‚Üí Crear Nuevo**
2. Completa el formulario:
   - Nombre del espacio (ej: "Sal√≥n de Eventos", "Gimnasio", "Piscina")
   - Comunidad a la que pertenece
   - Descripci√≥n del espacio
   - Capacidad m√°xima (n√∫mero de personas)
   - Caracter√≠sticas y equipamiento disponible
3. Configura horarios:
   - Define d√≠as y horarios de disponibilidad
   - Establece si requiere reserva previa
   - Define tiempo m√≠nimo/m√°ximo de reserva
4. Activa el espacio y guarda
5. Los residentes podr√°n ver y reservar este espacio inmediatamente

**üéØ Para consultar:**
‚Ä¢ Ver espacios: Escribe "espacios comunes" para ver todos los espacios del sistema
‚Ä¢ Ver reservas: Escribe "reservas" para ver todas las reservas activas

**üí° Tip:** Escribe "mu√©strame los espacios comunes" para ver datos reales de la base de datos.`,
          };
        } else if (isCommunityAdmin) {
          return {
            answer: `üè¢ **C√≥mo gestionar Espacios Comunes - Administrador de Comunidad**

Como Administrador de Comunidad, puedes crear, registrar y gestionar completamente los espacios comunes de tus comunidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver y gestionar espacios comunes de tus comunidades
‚Ä¢ Crear/Registrar nuevos espacios comunes (sal√≥n, gimnasio, piscina, etc.)
‚Ä¢ Editar espacios existentes
‚Ä¢ Configurar horarios de disponibilidad para cada espacio
‚Ä¢ Activar/desactivar espacios seg√∫n necesidades
‚Ä¢ Ver todas las reservas de tus comunidades
‚Ä¢ Aprobar o rechazar reservas pendientes

**üéØ Pasos para crear/registrar un nuevo espacio com√∫n:**
1. Desde el panel: **Administraci√≥n ‚Üí Gesti√≥n de Comunidad ‚Üí Espacios Comunes ‚Üí Crear Nuevo**
2. Completa el formulario:
   - Nombre del espacio (ej: "Sal√≥n de Eventos", "Gimnasio Central")
   - Descripci√≥n del espacio y caracter√≠sticas
   - Capacidad m√°xima de personas
   - Equipamiento disponible (si aplica)
3. Configura disponibilidad:
   - Define d√≠as y horarios de operaci√≥n
   - Establece si requiere aprobaci√≥n para reservas
   - Configura tiempo m√≠nimo/m√°ximo de reserva
   - Define pol√≠ticas de uso
4. Revisa y activa el espacio
5. Guarda y los residentes podr√°n verlo y reservarlo

**üéØ Para consultar:**
‚Ä¢ Ver espacios: Escribe "espacios comunes" para ver todos los espacios de tus comunidades
‚Ä¢ Ver reservas: Escribe "reservas" para ver reservas activas y pendientes

**üí° Tip:** Escribe "mu√©strame los espacios comunes" o "quiero ver las reservas" para ver datos espec√≠ficos.`,
          };
        } else if (isConcierge) {
          return {
            answer: `üè¢ **C√≥mo gestionar Espacios Comunes - Conserje**

Como Conserje, puedes consultar y gestionar informaci√≥n operativa sobre espacios comunes de tu comunidad.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver espacios comunes disponibles de tu comunidad
‚Ä¢ Consultar horarios y disponibilidad
‚Ä¢ Ver reservas programadas
‚Ä¢ Verificar qu√© espacios est√°n reservados y por qui√©n

**üéØ Pasos para usar:**
1. **Ver espacios:** Escribe "espacios comunes" para ver los espacios de tu comunidad con sus horarios
2. **Ver reservas:** Escribe "reservas" para ver qu√© espacios est√°n reservados y cu√°ndo
3. **Consultar disponibilidad:** Puedes preguntar "¬øqu√© espacios est√°n disponibles hoy?"

**üí° Tip:** Escribe "mu√©strame las reservas" para ver datos espec√≠ficos de la base de datos.`,
          };
        } else if (isResident) {
          return {
            answer: `üè¢ **C√≥mo usar Espacios Comunes - Residente**

Como Residente, puedes ver espacios disponibles y crear reservas para tu comunidad.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver espacios comunes disponibles de tu comunidad
‚Ä¢ Consultar horarios de cada espacio
‚Ä¢ Crear reservas de espacios comunes
‚Ä¢ Ver tus reservas activas y pasadas
‚Ä¢ Cancelar reservas si es necesario

**üéØ Pasos para usar:**
1. **Ver espacios disponibles:** Escribe "espacios comunes" para ver todos los espacios y sus horarios
2. **Crear una reserva:** Desde la interfaz, ve a Espacios Comunes ‚Üí Selecciona un espacio ‚Üí Elige fecha y hora
3. **Ver mis reservas:** Escribe "reservas" o accede a tu perfil ‚Üí Mis Reservas

**üí° Tip:** Para ver tus reservas espec√≠ficas, escribe "mu√©strame mis reservas" o "quiero ver mis reservas".`,
          };
        }
        break;

      case 'avisos':
        if (isSuperAdmin || isCommunityAdmin) {
          return {
            answer: `üì¢ **C√≥mo gestionar Avisos Comunitarios - Administrador**

Como Administrador, puedes crear, registrar y gestionar avisos para comunicarte con los residentes.

**üìã Funcionalidades disponibles:**
‚Ä¢ Crear/Registrar nuevos avisos (generales, urgentes, mantenimiento, seguridad, sociales)
‚Ä¢ Editar avisos existentes
‚Ä¢ Activar/desactivar avisos
‚Ä¢ Ver todos los avisos de tus comunidades
‚Ä¢ Publicar avisos inmediatamente o programarlos

**üéØ Pasos para crear/registrar un aviso:**
1. Desde el panel de administraci√≥n: **Avisos ‚Üí Crear Nuevo Aviso**
2. Completa el formulario:
   - Selecciona el tipo de aviso (General, Urgente, Mantenimiento, Seguridad, Social, etc.)
   - Escribe un t√≠tulo descriptivo
   - Escribe el contenido del aviso (descripci√≥n detallada)
   - Selecciona la comunidad de destino (si administras varias)
3. Configura la publicaci√≥n:
   - Publica inmediatamente: El aviso se publica al guardar
   - Programa para m√°s tarde: Selecciona fecha y hora de publicaci√≥n
4. Opcional: Adjunta archivos o im√°genes si es necesario
5. Guarda el aviso

**üí° Consejos:**
‚Ä¢ Los avisos urgentes aparecen destacados y generan notificaciones a los residentes
‚Ä¢ Puedes editar o desactivar avisos despu√©s de crearlos
‚Ä¢ Los residentes ver√°n los avisos en su dashboard y recibir√°n notificaciones de los importantes

**üí° Para ver avisos existentes:** Escribe "mu√©strame los avisos" o "quiero ver los avisos".`,
          };
        } else {
          return {
            answer: `üì¢ **C√≥mo ver Avisos Comunitarios - Residente/Conserje**

Puedes ver los avisos y comunicados de tu comunidad. Solo los Administradores pueden crear/registrar nuevos avisos.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver avisos recientes de tu comunidad
‚Ä¢ Filtrar por tipo de aviso (General, Urgente, Mantenimiento, etc.)
‚Ä¢ Recibir notificaciones de avisos importantes
‚Ä¢ Consultar historial de avisos

**üéØ Pasos para ver avisos:**
1. **Desde el chatbot:** Escribe "avisos" o "mu√©strame los avisos" para ver los m√°s recientes
2. **Desde la interfaz:** Secci√≥n de Avisos en el dashboard principal
3. **Notificaciones:** Los avisos urgentes aparecen destacados y generan notificaciones

**üìù Nota importante:** 
‚Ä¢ Solo los Administradores de Comunidad pueden crear/registrar nuevos avisos
‚Ä¢ Si necesitas que se publique un aviso, contacta a tu administrador de comunidad

**üí° Tip:** Escribe "mu√©strame los avisos" para ver datos reales de avisos de la base de datos.`,
          };
        }

      case 'gastos_comunes':
        if (isResident) {
          return {
            answer: `üí∞ **C√≥mo ver tus Gastos Comunes - Residente**

Puedes consultar tus gastos comunes y estado de pagos.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver gastos comunes de tus unidades
‚Ä¢ Consultar cu√°nto debes
‚Ä¢ Ver historial de pagos realizados
‚Ä¢ Ver detalles de cada gasto (categor√≠a, monto, fecha de vencimiento)

**üéØ Pasos para usar:**
1. **Ver mis gastos:** Escribe "gastos comunes" o "mis gastos"
2. **Consultar deudas:** Escribe "cuanto debo" para ver el total adeudado
3. **Ver detalles:** Escribe "mu√©strame mis gastos" para ver datos espec√≠ficos
4. **Desde la interfaz:** Dashboard ‚Üí Gastos Comunes ‚Üí Mis Gastos

**üí° Tip:** Escribe "mu√©strame mis gastos" o "quiero ver cu√°nto debo" para obtener datos reales de la base de datos.`,
          };
        } else if (isCommunityAdmin || isSuperAdmin) {
          return {
            answer: `üí∞ **C√≥mo gestionar Gastos Comunes - Administrador**

Como Administrador, puedes crear, registrar y gestionar gastos comunes de tus comunidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Crear/Registrar nuevos gastos comunes para la comunidad
‚Ä¢ Asignar gastos a unidades espec√≠ficas o a todas
‚Ä¢ Ver gastos pendientes de todas las unidades
‚Ä¢ Gestionar categor√≠as de gastos (mantenimiento, servicios, administraci√≥n, etc.)
‚Ä¢ Ver reportes financieros de la comunidad
‚Ä¢ Editar y anular gastos seg√∫n sea necesario

**üéØ Pasos para crear/registrar un gasto com√∫n:**
1. Desde el panel: **Administraci√≥n ‚Üí Gastos Comunes ‚Üí Crear Nuevo**
2. Completa el formulario:
   - Selecciona la categor√≠a del gasto (Mantenimiento, Servicios, Administraci√≥n, etc.)
   - Ingresa el monto total
   - Fecha de vencimiento para el pago
   - Descripci√≥n del gasto (opcional pero recomendado)
3. Asignaci√≥n:
   - Asigna a unidades espec√≠ficas (selecciona las unidades)
   - O asigna a todas las unidades autom√°ticamente
4. Revisa la informaci√≥n y guarda
5. El sistema notificar√° autom√°ticamente a los residentes afectados

**üí° Consejos:**
‚Ä¢ Los gastos se distribuyen seg√∫n los coeficientes de cada unidad
‚Ä¢ Puedes ver el estado de pago de cada unidad despu√©s de crear el gasto
‚Ä¢ Los residentes recibir√°n notificaciones cuando se registre un nuevo gasto

**üí° Tip:** Para ver datos espec√≠ficos, escribe "mu√©strame los gastos comunes" o "quiero ver las deudas pendientes".`,
          };
        }
        break;

      case 'visitantes':
        if (isResident) {
          return {
            answer: `üë• **C√≥mo gestionar Visitantes - Residente**

Puedes registrar/crear visitantes para tus unidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Registrar/Crear visitantes antes de su llegada
‚Ä¢ Ver tus visitantes registrados y su estado
‚Ä¢ Actualizar informaci√≥n de visitantes existentes
‚Ä¢ Ver historial de visitantes anteriores
‚Ä¢ Consultar estado de visitantes en tiempo real

**üéØ Pasos para registrar/crear un visitante:**
1. Desde la interfaz: **Dashboard ‚Üí Visitantes ‚Üí Registrar Nuevo**
2. Completa el formulario:
   - Nombre completo del visitante
   - N√∫mero de documento/identificaci√≥n
   - Tel√©fono de contacto
   - Prop√≥sito de la visita
   - Fecha y hora esperada de llegada
   - Unidad de destino (selecciona de tus unidades)
3. Revisa la informaci√≥n y guarda el registro
4. El conserje recibir√° una notificaci√≥n autom√°tica

**üí° Tip:** Para ver tus visitantes, escribe "mu√©strame mis visitantes" o "quiero ver mis visitantes registrados".`,
          };
        } else if (isConcierge) {
          return {
            answer: `üë• **C√≥mo gestionar Visitantes - Conserje**

Como Conserje, gestionas el registro operativo de visitantes de tu comunidad.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver todos los visitantes registrados de la comunidad
‚Ä¢ Actualizar estado de visitantes (Registrado ‚Üí Ingres√≥ ‚Üí Sali√≥)
‚Ä¢ Verificar identificaci√≥n de visitantes
‚Ä¢ Consultar visitantes programados para el d√≠a

**üéØ Pasos para gestionar visitantes:**
1. **Ver visitantes del d√≠a:** Escribe "visitantes" o "mu√©strame los visitantes"
2. **Cuando llega un visitante:** Actualiza el estado a "Ingres√≥"
3. **Cuando sale:** Actualiza el estado a "Sali√≥"
4. Desde la interfaz: Secci√≥n de Visitantes ‚Üí Gestionar

**üí° Tip:** Escribe "mu√©strame los visitantes de hoy" para ver datos espec√≠ficos.`,
          };
        } else if (isCommunityAdmin || isSuperAdmin) {
          return {
            answer: `üë• **C√≥mo gestionar Visitantes - Administrador**

Puedes ver y gestionar visitantes de tus comunidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver todos los visitantes de tus comunidades
‚Ä¢ Consultar registro de visitantes por unidad
‚Ä¢ Ver estad√≠sticas de visitantes
‚Ä¢ Gestionar permisos de registro de visitantes

**üéØ Pasos para usar:**
1. **Ver visitantes:** Escribe "visitantes" o "mu√©strame los visitantes"
2. **Consultar por unidad:** Puedes filtrar visitantes por unidad espec√≠fica
3. Desde la interfaz: Panel ‚Üí Gesti√≥n de Comunidad ‚Üí Visitantes

**üí° Tip:** Escribe "mu√©strame los visitantes" para ver datos reales de la base de datos.`,
          };
        }
        break;

      case 'encomiendas':
        if (isResident) {
          return {
            answer: `üì¶ **C√≥mo ver tus Encomiendas - Residente**

Puedes ver las encomiendas recibidas en tus unidades. Solo el Conserje puede registrar nuevas encomiendas cuando llegan.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver encomiendas recibidas en tus unidades
‚Ä¢ Consultar estado de paquetes (recibido, retirado)
‚Ä¢ Ver fecha de recepci√≥n de cada encomienda
‚Ä¢ Recibir notificaciones cuando llegue una nueva encomienda

**üéØ Pasos para usar:**
1. **Ver mis encomiendas:** Escribe "encomiendas" o "mis encomiendas"
2. **Consultar datos:** Escribe "mu√©strame mis encomiendas" para ver datos espec√≠ficos
3. **Desde la interfaz:** Dashboard ‚Üí Encomiendas
4. Cuando recibas una notificaci√≥n, puedes ver los detalles del paquete

**üìù Nota importante:** 
‚Ä¢ El Conserje registra las encomiendas cuando llegan al edificio
‚Ä¢ Recibir√°s una notificaci√≥n cuando tengas una nueva encomienda
‚Ä¢ Debes retirar tus paquetes en el plazo establecido

**üí° Tip:** Para ver datos espec√≠ficos, escribe "mu√©strame mis encomiendas" o "quiero ver mis paquetes".`,
          };
        } else if (isConcierge) {
          return {
            answer: `üì¶ **C√≥mo gestionar Encomiendas - Conserje**

Como Conserje, puedes registrar, crear y gestionar encomiendas en tu comunidad.

**üìã Funcionalidades disponibles:**
‚Ä¢ Registrar/Crear nuevas encomiendas cuando llegan
‚Ä¢ Ver todas las encomiendas recibidas en la comunidad
‚Ä¢ Actualizar estado de encomiendas (Recibido ‚Üí Retirado)
‚Ä¢ Consultar encomiendas pendientes de retiro
‚Ä¢ Notificar a residentes cuando llegue una encomienda

**üéØ Pasos para registrar/crear una encomienda:**
1. **Cuando llega una encomienda al edificio:**
   - Desde la interfaz: **Secci√≥n de Encomiendas ‚Üí Registrar Nueva**
   - O desde el chatbot: Puedes usar la consulta r√°pida
2. **Completa el formulario:**
   - Nombre del destinatario (residente)
   - Unidad de destino
   - Empresa de env√≠o (si aplica)
   - N√∫mero de rastreo (si est√° disponible)
   - Descripci√≥n del paquete (tama√±o, tipo)
   - Fecha y hora de recepci√≥n
3. **Guarda el registro:**
   - El sistema notificar√° autom√°ticamente al residente
   - El estado inicial ser√° "Recibido"

**üéØ Para gestionar encomiendas existentes:**
1. **Ver encomiendas pendientes:** Escribe "encomiendas" o "mu√©strame las encomiendas"
2. **Cuando un residente retira:** 
   - Actualiza el estado a "Retirado"
   - Registra la fecha y hora de retiro
3. **Consultar por unidad:** Puedes filtrar encomiendas por unidad espec√≠fica

**üí° Consejos:**
‚Ä¢ Registra las encomiendas inmediatamente al recibirlas
‚Ä¢ Notifica a los residentes para que retiren sus paquetes
‚Ä¢ Mant√©n un registro ordenado facilitar√° la gesti√≥n

**üí° Tip:** Escribe "mu√©strame las encomiendas pendientes" para ver datos espec√≠ficos.`,
          };
        } else if (isCommunityAdmin || isSuperAdmin) {
          return {
            answer: `üì¶ **C√≥mo gestionar Encomiendas - Administrador**

Puedes ver y gestionar encomiendas de tus comunidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver todas las encomiendas de tus comunidades
‚Ä¢ Consultar encomiendas por unidad
‚Ä¢ Ver estad√≠sticas de encomiendas recibidas y retiradas

**üéØ Pasos para usar:**
1. **Ver encomiendas:** Escribe "encomiendas" o "mu√©strame las encomiendas"
2. **Consultar por unidad:** Puedes filtrar por unidad espec√≠fica
3. Desde la interfaz: Panel ‚Üí Gesti√≥n de Comunidad ‚Üí Encomiendas

**üí° Tip:** Escribe "mu√©strame las encomiendas" para ver datos reales de la base de datos.`,
          };
        }
        break;

      case 'reservas':
        if (isResident) {
          return {
            answer: `üìÖ **C√≥mo hacer Reservas de Espacios Comunes - Residente**

Puedes crear/registrar reservas de espacios comunes de tu comunidad.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver espacios disponibles y sus horarios
‚Ä¢ Crear/Registrar nuevas reservas de espacios comunes
‚Ä¢ Ver tus reservas activas y pasadas
‚Ä¢ Editar reservas existentes (si est√° permitido)
‚Ä¢ Cancelar reservas si es necesario

**üéØ Pasos para crear/registrar una reserva:**
1. **Consulta espacios disponibles:**
   - Escribe "espacios comunes" para ver espacios y horarios disponibles
   - O ve a la interfaz: **Dashboard ‚Üí Espacios Comunes**
2. **Selecciona el espacio:**
   - Elige el espacio que deseas reservar
   - Revisa los horarios disponibles y restricciones
3. **Completa la reserva:**
   - Selecciona la fecha deseada
   - Elige el horario disponible (hora de inicio y fin)
   - Revisa si hay pol√≠ticas especiales o costos
4. **Confirma y env√≠a:**
   - Revisa todos los detalles
   - Confirma la reserva
   - Recibir√°s una confirmaci√≥n autom√°tica
5. Si la reserva requiere aprobaci√≥n, te llegar√° una notificaci√≥n cuando sea aprobada

**üí° Consejos:**
‚Ä¢ Reserva con anticipaci√≥n para asegurar disponibilidad
‚Ä¢ Revisa las pol√≠ticas de uso del espacio antes de reservar
‚Ä¢ Puedes cancelar tu reserva si cambias de planes (respetando los plazos)

**üí° Tip:** Para ver tus reservas, escribe "mu√©strame mis reservas" o "quiero ver mis reservas".`,
          };
        } else if (isConcierge || isCommunityAdmin || isSuperAdmin) {
          return {
            answer: `üìÖ **C√≥mo gestionar Reservas - Administrador/Conserje**

Puedes ver y gestionar reservas de espacios comunes.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver todas las reservas de espacios comunes
‚Ä¢ Consultar calendario de reservas
‚Ä¢ Aprobar o rechazar reservas (si aplica seg√∫n tu rol)
‚Ä¢ Ver disponibilidad de espacios

**üéØ Pasos para usar:**
1. **Ver reservas:** Escribe "reservas" o "mu√©strame las reservas"
2. **Consultar disponibilidad:** Escribe "espacios comunes" para ver horarios
3. Desde la interfaz: Gesti√≥n ‚Üí Reservas

**üí° Tip:** Escribe "mu√©strame las reservas" para ver datos espec√≠ficos de la base de datos.`,
          };
        }
        break;

      case 'incidencias':
        if (isResident) {
          return {
            answer: `üö® **C√≥mo reportar Incidencias - Residente**

Puedes crear/registrar reportes de problemas o incidencias en tu comunidad.

**üìã Funcionalidades disponibles:**
‚Ä¢ Crear/Registrar reportes de incidencias
‚Ä¢ Ver tus incidencias reportadas y su estado actual
‚Ä¢ Consultar historial de incidencias resueltas
‚Ä¢ Agregar comentarios o actualizaciones a tus reportes

**üéØ Pasos para reportar/crear una incidencia:**
1. Desde la interfaz: **Dashboard ‚Üí Incidencias ‚Üí Reportar Nueva**
2. Completa el formulario:
   - T√≠tulo del problema (ej: "Fuga de agua en pasillo")
   - Descripci√≥n detallada del problema
   - Categor√≠a/tipo de incidencia (Mantenimiento, Seguridad, Ruido, etc.)
   - Ubicaci√≥n espec√≠fica (si aplica)
   - Adjunta fotos o documentos si es necesario
3. Revisa la informaci√≥n y env√≠a el reporte
4. La administraci√≥n recibir√° una notificaci√≥n autom√°tica
5. Puedes consultar el estado en cualquier momento

**üí° Consejos:**
‚Ä¢ S√© espec√≠fico en la descripci√≥n para una resoluci√≥n m√°s r√°pida
‚Ä¢ Incluye fotos cuando sea posible
‚Ä¢ Puedes seguir el estado de tus reportes desde tu dashboard

**üí° Tip:** Para ver tus incidencias, escribe "mu√©strame mis incidencias" o "quiero ver mis reportes".`,
          };
        }
        break;

      case 'ingresos':
        if (isCommunityAdmin || isSuperAdmin) {
          return {
            answer: `üíµ **C√≥mo gestionar Ingresos Comunitarios - Administrador**

Como Administrador, puedes registrar, crear y gestionar ingresos de tus comunidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Registrar/Crear ingresos comunitarios (rentas, alquileres, servicios, etc.)
‚Ä¢ Ver historial de ingresos por per√≠odo
‚Ä¢ Gestionar categor√≠as de ingresos
‚Ä¢ Ver reportes financieros con ingresos
‚Ä¢ Exportar reportes de ingresos
‚Ä¢ Editar y anular ingresos registrados

**üéØ Pasos para registrar/crear un ingreso:**
1. Desde el panel: **Administraci√≥n ‚Üí Ingresos ‚Üí Crear Nuevo**
2. Completa el formulario:
   - **Categor√≠a del ingreso:**
     * Rentas de espacios comunes
     * Alquileres
     * Servicios adicionales
     * Multas y recargos
     * Otros ingresos
   - **Informaci√≥n del ingreso:**
     * Monto recibido
     * Per√≠odo de facturaci√≥n (mes/a√±o)
     * Descripci√≥n del ingreso
     * Fecha de recepci√≥n
   - **Origen del ingreso:**
     * Unidad espec√≠fica (si aplica)
     * Fuente del ingreso
3. Revisa la informaci√≥n y guarda
4. El ingreso se registrar√° en los reportes financieros

**üéØ Para consultar ingresos:**
1. **Ver ingresos:** Escribe "ingresos" o "mu√©strame los ingresos"
2. **Consultar por per√≠odo:** Puedes filtrar por mes, a√±o o rango de fechas
3. **Reportes financieros:** Accede a Reportes ‚Üí Ingresos para ver an√°lisis detallados

**üí° Consejos:**
‚Ä¢ Registra los ingresos tan pronto como se reciban
‚Ä¢ Clasifica correctamente cada ingreso para reportes precisos
‚Ä¢ Revisa peri√≥dicamente los ingresos vs gastos de la comunidad

**üí° Tip:** Para ver datos espec√≠ficos, escribe "mu√©strame los ingresos" o "quiero ver los ingresos del mes".`,
          };
        }
        break;

      case 'residentes':
        if (isCommunityAdmin || isSuperAdmin) {
          return {
            answer: `üë• **C√≥mo gestionar Residentes - Administrador**

Como Administrador, puedes crear, registrar y gestionar residentes de tus comunidades.

**üìã Funcionalidades disponibles:**
‚Ä¢ Crear/Registrar nuevos residentes en tus comunidades
‚Ä¢ Editar informaci√≥n de residentes existentes
‚Ä¢ Asignar unidades a residentes
‚Ä¢ Ver todos los residentes de tus comunidades
‚Ä¢ Gestionar roles y permisos de residentes
‚Ä¢ Ver unidades disponibles y ocupadas
‚Ä¢ Desactivar residentes cuando corresponda

**üéØ Pasos para crear/registrar un nuevo residente:**
1. Desde el panel: **Gesti√≥n de Comunidad ‚Üí Residentes ‚Üí Crear Nuevo**
2. Completa el formulario:
   - Informaci√≥n personal:
     * Nombre completo
     * Documento de identidad
     * Tel√©fono de contacto
     * Email (si est√° disponible)
   - Informaci√≥n de la comunidad:
     * Selecciona la comunidad
     * Tipo de residente (Propietario, Inquilino, Residente)
   - Asignaci√≥n de unidad:
     * Selecciona la unidad a asignar
     * O crea la unidad primero si no existe
3. Configura permisos y roles:
   - Asigna los roles apropiados seg√∫n el tipo de residente
   - Define permisos de acceso al sistema
4. Revisa la informaci√≥n y guarda
5. El residente recibir√° credenciales de acceso (si aplica)

**üéØ Para gestionar residentes existentes:**
1. **Ver residentes:** Escribe "residentes" o "mu√©strame los residentes"
2. **Editar informaci√≥n:** Selecciona el residente ‚Üí Editar
3. **Cambiar unidad:** Puedes reasignar unidades a residentes
4. **Gestionar desde interfaz:** Panel ‚Üí Gesti√≥n de Comunidad ‚Üí Residentes

**üí° Consejos:**
‚Ä¢ Verifica que la unidad est√© disponible antes de asignar
‚Ä¢ Mant√©n la informaci√≥n de contacto actualizada
‚Ä¢ Revisa peri√≥dicamente las asignaciones de unidades

**üí° Tip:** Escribe "mu√©strame los residentes" para ver datos reales de la base de datos.`,
          };
        }
        break;

      case 'organizaciones':
        if (isSuperAdmin) {
          return {
            answer: `üè¢ **C√≥mo gestionar Organizaciones - Super Administrador**

Como Super Administrador, puedes crear, registrar y gestionar todas las organizaciones del sistema.

**üìã Funcionalidades disponibles:**
‚Ä¢ Crear/Registrar nuevas organizaciones en el sistema
‚Ä¢ Ver todas las organizaciones del sistema
‚Ä¢ Editar informaci√≥n de organizaciones existentes
‚Ä¢ Gestionar planes y suscripciones de organizaciones
‚Ä¢ Activar/desactivar organizaciones
‚Ä¢ Gestionar usuarios administradores de organizaciones

**üéØ Pasos para crear/registrar una nueva organizaci√≥n:**
1. Desde el panel: **Super Administraci√≥n ‚Üí Organizaciones ‚Üí Crear Nueva**
2. Completa el formulario:
   - **Informaci√≥n b√°sica:**
     * Nombre de la organizaci√≥n
     * RUT o identificaci√≥n fiscal
     * Direcci√≥n
     * Tel√©fono de contacto
     * Email de contacto
   - **Configuraci√≥n del sistema:**
     * Plan de suscripci√≥n (B√°sico, Premium, Enterprise)
     * L√≠mites de usuarios/comunidades seg√∫n el plan
     * Configuraciones de facturaci√≥n
   - **Administrador inicial:**
     * Crea o asigna un usuario administrador
     * Define permisos del administrador
3. Revisa la informaci√≥n y activa la organizaci√≥n
4. Guarda y la organizaci√≥n estar√° lista para usar

**üéØ Para gestionar organizaciones existentes:**
1. **Ver organizaciones:** Escribe "organizaciones" o "mu√©strame las organizaciones"
2. **Editar informaci√≥n:** Selecciona la organizaci√≥n ‚Üí Editar
3. **Gestionar planes:** Cambia el plan de suscripci√≥n seg√∫n necesidades
4. **Usuarios:** Gestiona administradores y usuarios de la organizaci√≥n

**üí° Consejos:**
‚Ä¢ Verifica que la informaci√≥n fiscal sea correcta para facturaci√≥n
‚Ä¢ Asigna el plan adecuado seg√∫n las necesidades de la organizaci√≥n
‚Ä¢ Revisa peri√≥dicamente el uso vs l√≠mites del plan

**üí° Tip:** Escribe "mu√©strame las organizaciones" para ver datos espec√≠ficos.`,
          };
        }
        break;

      case 'metricas':
        if (isSuperAdmin) {
          return {
            answer: `üìä **C√≥mo ver M√©tricas del Sistema - Super Administrador**

Puedes ver m√©tricas y estad√≠sticas globales del sistema.

**üìã Funcionalidades disponibles:**
‚Ä¢ Ver m√©tricas del sistema (usuarios, comunidades, unidades, etc.)
‚Ä¢ Ver estad√≠sticas de uso
‚Ä¢ Ver reportes globales
‚Ä¢ Consultar salud del sistema

**üéØ Pasos para usar:**
1. **Ver m√©tricas:** Escribe "m√©tricas del sistema" o "estad√≠sticas"
2. **Desde la interfaz:** Panel de Super Admin ‚Üí M√©tricas del Sistema
3. Puedes ver diferentes tipos de reportes y an√°lisis

**üí° Tip:** Escribe "mu√©strame las m√©tricas" para ver datos espec√≠ficos del sistema.`,
          };
        }
        break;
    }

    // Si no hay explicaci√≥n espec√≠fica, retornar null para que contin√∫e con el flujo normal
    return null;
  }

  private async getCommonSpacesInfo(): Promise<ChatbotResponseDto> {
    try {
      const spaces = await this.prisma.communityCommonSpace.findMany({
        where: { isActive: true },
        include: {
          schedules: {
            where: { isActive: true },
            orderBy: { dayOfWeek: 'asc' },
          },
        },
        orderBy: { name: 'asc' },
      });

      if (spaces.length === 0) {
        return {
          answer:
            'üìã **Espacios Comunes**\n\n' +
            '‚ùå No hay espacios comunes registrados actualmente.\n\n' +
            'üí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*',
        };
      }

      let response = 'üìã **ESPACIOS COMUNES DISPONIBLES**\n';
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < spaces.length; i++) {
        const space = spaces[i];
        const status = space.isActive ? '‚úÖ Disponible' : '‚ùå No disponible';

        response += `üè¢ **${space.name}**\n`;
        response += `   üìä Estado: ${status}\n`;

        if (space.description) {
          response += `   üìù Descripci√≥n: ${space.description}\n`;
        }

        response += `   üî¢ Cantidad: ${space.quantity}\n`;

        if (space.schedules.length > 0) {
          response += `   üïí **Horarios de Atenci√≥n:**\n`;

          // Agrupar horarios por d√≠a
          const scheduleGroups = this.groupSchedulesByTime(space.schedules);

          for (const [timeRange, days] of Object.entries(scheduleGroups)) {
            const dayList = days.map((day) => this.getDayName(day)).join(', ');
            response += `      ‚Ä¢ ${dayList}: ${timeRange}\n`;
          }
        } else {
          response += `   ‚ö†Ô∏è  *No hay horarios registrados*\n`;
        }

        response += '\n';

        // Agregar separador entre espacios (excepto el √∫ltimo)
        if (i < spaces.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      response += '‚Ä¢ Para reservar un espacio, contacta a la administraci√≥n\n';
      response += '‚Ä¢ Los horarios pueden variar en d√≠as festivos\n';
      response += '‚Ä¢ Se requiere reserva previa para eventos especiales';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting common spaces info:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de espacios comunes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getCommunityAnnouncements(): Promise<ChatbotResponseDto> {
    try {
      const announcements = await this.prisma.announcement.findMany({
        where: { isActive: true },
        orderBy: { publishedAt: 'desc' },
        take: 5,
      });

      if (announcements.length === 0) {
        return {
          answer:
            'üì¢ **Avisos Comunitarios**\n\n' +
            'üì≠ No hay avisos registrados actualmente.\n\n' +
            'üí° *Mantente atento a futuras comunicaciones de la administraci√≥n.*',
        };
      }

      let response = 'üì¢ **√öLTIMOS AVISOS COMUNITARIOS**\n';
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < announcements.length; i++) {
        const announcement = announcements[i];
        const date = announcement.publishedAt.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        // Determinar el emoji seg√∫n el tipo de anuncio
        const typeEmoji = this.getAnnouncementTypeEmoji(announcement.type);

        response += `${typeEmoji} **${announcement.title}**\n`;
        response += `   üìÖ Fecha: ${date}\n`;
        response += `   üè∑Ô∏è  Tipo: ${this.getAnnouncementTypeName(announcement.type)}\n`;
        response += `   üìÑ Contenido: ${announcement.content}\n`;

        response += '\n';

        // Agregar separador entre anuncios (excepto el √∫ltimo)
        if (i < announcements.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      response += '‚Ä¢ Los avisos se actualizan regularmente\n';
      response += '‚Ä¢ Contacta a la administraci√≥n para m√°s detalles\n';
      response += '‚Ä¢ Revisa peri√≥dicamente para estar informado';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting community announcements:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener los avisos de la comunidad.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async queryOpenAI(question: string): Promise<ChatbotResponseDto> {
    try {
      // Verificar cache primero
      const cachedResponse = this.getCachedResponse(question);
      if (cachedResponse) {
        return { answer: cachedResponse };
      }

      // Rate limiting deshabilitado para testing
      // if (this.isRateLimited()) {
      //   this.logger.warn('Rate limit exceeded, using fallback response');
      //   return { answer: this.getFallbackResponse(question) };
      // }

      const openaiKey = this.configService.get<string>('OPENAI_API_KEY');

      if (!openaiKey) {
        this.logger.error('OPENAI_API_KEY not configured');
        return { answer: 'El servicio de IA no est√° configurado correctamente.' };
      }

      // Aplicar delay inteligente para evitar rate limiting
      await this.ensureRequestDelay();

      // Obtener informaci√≥n contextual del sistema
      const contextInfo = await this.getSystemContext();

      const payload = {
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `Eres ComunIAssistant, un asistente virtual especializado √öNICAMENTE en Comuniapp (plataforma de gesti√≥n comunitaria).

## IDENTIDAD Y PERSONALIDAD
- Asistente amigable, profesional y experto en la plataforma Comuniapp
- Respondes preferentemente en espa√±ol latinoamericano
- Usas emojis estrat√©gicamente para mejorar la comunicaci√≥n
- Eres √∫til, informativo y conversacional

## ‚ö†Ô∏è ALCANCE LIMITADO - SOLO COMUNIAPP
**IMPORTANTE:** Solo debes responder preguntas relacionadas con Comuniapp y gesti√≥n comunitaria.

**TEMAS PERMITIDOS:**
‚úÖ Gesti√≥n de comunidades
‚úÖ Espacios comunes y reservas
‚úÖ Gastos comunes y pagos
‚úÖ Visitantes
‚úÖ Encomiendas
‚úÖ Avisos comunitarios
‚úÖ Residentes y unidades
‚úÖ Incidencias y reportes
‚úÖ Administraci√≥n de comunidades
‚úÖ Funcionalidades de Comuniapp
‚úÖ C√≥mo usar Comuniapp
‚úÖ Consultas sobre el sistema Comuniapp

**TEMAS PROHIBIDOS (NO RESPONDAS SOBRE):**
‚ùå Deportes
‚ùå Entretenimiento
‚ùå Noticias generales
‚ùå Historia, cultura, arte
‚ùå Programaci√≥n o tecnolog√≠a general
‚ùå Salud y medicina
‚ùå Cualquier tema ajeno a Comuniapp

**Si el usuario pregunta sobre un tema fuera de Comuniapp:**
- Indica cort√©smente que solo puedes ayudar con temas relacionados con Comuniapp
- Ofrece informaci√≥n sobre las funcionalidades disponibles de Comuniapp
- Sugiere c√≥mo puede usar Comuniapp para sus necesidades

## INFORMACI√ìN DEL SISTEMA
${contextInfo}

**Funcionalidades principales de Comuniapp:**
‚Ä¢ üè¢ Espacios comunes y reservas
‚Ä¢ üí∞ Gastos comunes y pagos
‚Ä¢ üë• Gesti√≥n de visitantes
‚Ä¢ üì¶ Encomiendas
‚Ä¢ üì¢ Avisos comunitarios
‚Ä¢ üè† Unidades y residentes

## MANEJO DE SALUDOS Y DESPEDIDAS
- **Saludos:** Cuando el usuario saluda (hola, buenos d√≠as, hi, etc.), responde de manera amigable y natural, pero SIEMPRE en el contexto de Comuniapp
  * Ejemplo: "¬°Hola! üëã Soy ComunIAssistant, tu asistente virtual de Comuniapp. ¬øEn qu√© puedo ayudarte hoy con la gesti√≥n comunitaria?"
  * Menciona brevemente que puedes ayudar con funcionalidades de Comuniapp
  * Para usuarios no autenticados, mant√©n un saludo gen√©rico pero siempre relacionado con Comuniapp
  
- **Despedidas:** Cuando el usuario se despide o agradece (gracias, chao, adi√≥s, etc.), responde de manera c√°lida pero en el contexto de Comuniapp
  * Ejemplo: "¬°De nada! Fue un placer ayudarte con Comuniapp. Estoy aqu√≠ siempre que necesites gestionar tu comunidad. ¬°Que tengas un excelente d√≠a! üòä"
  * Reafirma tu disponibilidad para ayudar con Comuniapp
  * Mant√©n un tono profesional pero amigable

- **Siempre contextualiza:** Incluso los saludos y despedidas deben mencionar Comuniapp o la gesti√≥n comunitaria para mantener el foco
- **IMPORTANTE:** Para usuarios autenticados, los saludos y despedidas se adaptan autom√°ticamente seg√∫n su rol (ver instrucciones espec√≠ficas en el contexto del usuario)

## INSTRUCCIONES DE RESPUESTA
- **SOLO responde preguntas sobre Comuniapp y gesti√≥n comunitaria**
- **NUNCA respondas sobre temas externos** (deportes, entretenimiento, noticias, etc.)
- Si el usuario pregunta sobre un tema ajeno a Comuniapp, indica cort√©smente que solo puedes ayudar con Comuniapp
- S√© conversacional, natural y √∫til
- Proporciona informaci√≥n precisa y completa sobre Comuniapp
- Adapta tu tono seg√∫n la pregunta
- Usa emojis cuando sea apropiado
- Estructura la informaci√≥n de forma clara

## OBJETIVO PRINCIPAL
Ser un asistente especializado √öNICAMENTE en Comuniapp que proporciona respuestas claras, precisas y amigables sobre la plataforma y gesti√≥n comunitaria.`,
          },
          {
            role: 'user',
            content: question,
          },
        ],
        max_tokens: 500,
        temperature: 0.7,
      };

      const response = await fetch(this.OPENAI_API_URL, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${openaiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        return await this.handleOpenAIError(response, question);
      }

      const data = await response.json();
      const answer = data?.choices?.[0]?.message?.content || 'No se pudo obtener una respuesta.';

      // Guardar en cache
      this.setCachedResponse(question, answer);

      return { answer };
    } catch (error) {
      this.logger.error('Error querying OpenAI:', error);
      const errorMessage = error instanceof Error ? error.message : 'Error desconocido';

      // Si es error de rate limiting, usar fallback
      if (errorMessage.includes('429')) {
        return { answer: this.getFallbackResponse(question) };
      }

      return { answer: `Ocurri√≥ un error al comunicarse con la IA: ${errorMessage}` };
    }
  }

  private getDayName(dayOfWeek: string): string {
    const dayNames: Record<string, string> = {
      MONDAY: 'Lunes',
      TUESDAY: 'Martes',
      WEDNESDAY: 'Mi√©rcoles',
      THURSDAY: 'Jueves',
      FRIDAY: 'Viernes',
      SATURDAY: 'S√°bado',
      SUNDAY: 'Domingo',
    };
    return dayNames[dayOfWeek] || dayOfWeek;
  }

  private groupSchedulesByTime(schedules: any[]): Record<string, string[]> {
    const groups: Record<string, string[]> = {};

    for (const schedule of schedules) {
      const timeRange = `${schedule.startTime} - ${schedule.endTime}`;
      if (!groups[timeRange]) {
        groups[timeRange] = [];
      }
      groups[timeRange].push(schedule.dayOfWeek);
    }

    return groups;
  }

  private getAnnouncementTypeEmoji(type: string): string {
    const typeEmojis: Record<string, string> = {
      GENERAL: 'üì¢',
      URGENT: 'üö®',
      MAINTENANCE: 'üîß',
      SECURITY: 'üõ°Ô∏è',
      SOCIAL: 'üéâ',
    };
    return typeEmojis[type] || 'üì¢';
  }

  private getAnnouncementTypeName(type: string): string {
    const typeNames: Record<string, string> = {
      GENERAL: 'General',
      URGENT: 'Urgente',
      MAINTENANCE: 'Mantenimiento',
      SECURITY: 'Seguridad',
      SOCIAL: 'Social',
    };
    return typeNames[type] || 'General';
  }

  private async getCommonExpensesInfo(): Promise<ChatbotResponseDto> {
    try {
      const expenses = await this.prisma.communityExpense.findMany({
        where: {
          community: { isActive: true },
        },
        include: {
          community: true,
          items: {
            include: {
              category: true,
            },
          },
        },
        orderBy: { dueDate: 'desc' },
        take: 3,
      });

      if (expenses.length === 0) {
        return {
          answer:
            'üí∞ **Gastos Comunes**\n\n' +
            'üì≠ No hay gastos comunes registrados actualmente.\n\n' +
            'üí° *Contacta a la administraci√≥n para m√°s informaci√≥n sobre las cuotas.*',
        };
      }

      let response = 'üí∞ **√öLTIMOS GASTOS COMUNES**\n';
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < expenses.length; i++) {
        const expense = expenses[i];
        const dueDate = expense.dueDate.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
        });

        response += `üè¢ **${expense.community.name}**\n`;
        response += `   üìÖ Per√≠odo: ${expense.period}\n`;
        response += `   üíµ Total: $${expense.totalAmount.toFixed(2)}\n`;
        response += `   üìÜ Vencimiento: ${dueDate}\n`;
        response += `   üìä M√©todo: ${this.getProrrateMethodName(expense.prorrateMethod)}\n`;

        if (expense.items.length > 0) {
          response += `   üìã **Detalle de Gastos:**\n`;
          for (const item of expense.items.slice(0, 3)) {
            response += `      ‚Ä¢ ${item.name}: $${item.amount.toFixed(2)}\n`;
          }
          if (expense.items.length > 3) {
            response += `      ‚Ä¢ ... y ${expense.items.length - 3} m√°s\n`;
          }
        }

        response += '\n';

        if (i < expenses.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      response += '‚Ä¢ Los gastos se prorratean seg√∫n el coeficiente de cada unidad\n';
      response += '‚Ä¢ Contacta a la administraci√≥n para consultas espec√≠ficas\n';
      response += '‚Ä¢ Los pagos pueden realizarse por transferencia bancaria';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting common expenses info:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de gastos comunes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getVisitorsInfo(): Promise<ChatbotResponseDto> {
    try {
      const visitors = await this.prisma.visitor.findMany({
        where: {
          unit: {
            community: { isActive: true },
          },
        },
        include: {
          unit: {
            include: {
              community: true,
            },
          },
          host: {
            select: {
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        take: 5,
      });

      if (visitors.length === 0) {
        return {
          answer:
            'üë• **Registro de Visitantes**\n\n' +
            'üì≠ No hay visitantes registrados actualmente.\n\n' +
            'üí° *Los residentes pueden registrar visitas a trav√©s del sistema.*',
        };
      }

      let response = 'üë• **√öLTIMOS VISITANTES REGISTRADOS**\n';
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < visitors.length; i++) {
        const visitor = visitors[i];
        const arrivalDate = visitor.expectedArrival.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        const statusEmoji = this.getVisitorStatusEmoji(visitor.status);

        response += `${statusEmoji} **${visitor.visitorName}**\n`;
        response += `   üè† Unidad: ${visitor.unit.number} - ${visitor.unit.community.name}\n`;
        response += `   üë§ Anfitri√≥n: ${visitor.host.name}\n`;
        response += `   üìÖ Llegada: ${arrivalDate}\n`;
        response += `   üìã Prop√≥sito: ${this.getVisitPurposeName(visitor.visitPurpose)}\n`;
        response += `   üìä Estado: ${this.getVisitorStatusName(visitor.status)}\n`;

        if (visitor.visitorPhone) {
          response += `   üìû Tel√©fono: ${visitor.visitorPhone}\n`;
        }

        response += '\n';

        if (i < visitors.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      response += '‚Ä¢ Los visitantes deben registrarse antes de la visita\n';
      response += '‚Ä¢ Se requiere identificaci√≥n al ingresar\n';
      response += '‚Ä¢ Contacta a la administraci√≥n para m√°s detalles';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting visitors info:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de visitantes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getResidentsInfo(): Promise<ChatbotResponseDto> {
    try {
      const residents = await this.prisma.user.findMany({
        where: {
          isActive: true,
          roles: {
            some: {
              role: {
                name: 'RESIDENT',
              },
            },
          },
        },
        include: {
          userUnits: {
            include: {
              unit: {
                include: {
                  community: true,
                },
              },
            },
          },
          roles: {
            include: {
              role: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        take: 10,
      });

      if (residents.length === 0) {
        return {
          answer:
            'üë• **Registro de Residentes**\n\n' +
            'üì≠ No hay residentes registrados actualmente.\n\n' +
            'üí° *Los residentes se registran a trav√©s del sistema de administraci√≥n.*',
        };
      }

      let response = 'üë• RESIDENTES REGISTRADOS\n\n';
      response += '‚îÄ'.repeat(60) + '\n\n';

      for (let i = 0; i < residents.length; i++) {
        const resident = residents[i];
        const registrationDate = resident.createdAt.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
        });

        response += `üë§ ${resident.name}\n\n`;
        response += `üìß Email: ${resident.email}\n`;
        response += `üìÖ Registrado: ${registrationDate}\n`;

        if (resident.phone) {
          response += `üìû Tel√©fono: ${resident.phone}\n`;
        }

        if (resident.userUnits.length > 0) {
          response += `üè† Unidades: `;
          const units = resident.userUnits.map(
            (uu) => `${uu.unit.number} (${uu.unit.community.name})`,
          );
          response += units.join(', ') + '\n';
        }

        const roles = resident.roles.map((ur) => ur.role.name).join(', ');
        response += `üîë Roles: ${roles}\n\n`;

        if (i < residents.length - 1) {
          response += '‚îÄ'.repeat(40) + '\n\n';
        }
      }

      response += '\nüí° Informaci√≥n adicional:\n\n';
      response += '‚Ä¢ Los residentes tienen acceso a sus unidades asignadas\n';
      response += '‚Ä¢ Pueden gestionar visitantes y encomiendas\n';
      response += '‚Ä¢ Contacta a la administraci√≥n para m√°s detalles';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting residents info:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de residentes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getParcelsInfo(): Promise<ChatbotResponseDto> {
    try {
      const parcels = await this.prisma.parcel.findMany({
        where: {
          unit: {
            community: { isActive: true },
          },
        },
        include: {
          unit: {
            include: {
              community: true,
            },
          },
        },
        orderBy: { receivedAt: 'desc' },
        take: 5,
      });

      if (parcels.length === 0) {
        return {
          answer:
            'üì¶ **Encomiendas**\n\n' +
            'üì≠ No hay encomiendas registradas actualmente.\n\n' +
            'üí° *Las encomiendas se registran autom√°ticamente al llegar.*',
        };
      }

      let response = 'üì¶ **√öLTIMAS ENCOMIENDAS RECIBIDAS**\n';
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < parcels.length; i++) {
        const parcel = parcels[i];
        const receivedDate = parcel.receivedAt.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        const statusEmoji = this.getParcelStatusEmoji(parcel.status);

        response += `${statusEmoji} **${parcel.description}**\n`;
        response += `   üè† Unidad: ${parcel.unit.number} - ${parcel.unit.community.name}\n`;
        response += `   üìÖ Recibido: ${receivedDate}\n`;
        response += `   üìä Estado: ${this.getParcelStatusName(parcel.status)}\n`;

        if (parcel.sender) {
          response += `   üë§ Remitente: ${parcel.sender}\n`;
        }

        if (parcel.retrievedAt) {
          const retrievedDate = parcel.retrievedAt.toLocaleDateString('es-ES', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          });
          response += `   ‚úÖ Retirado: ${retrievedDate}\n`;
        }

        response += '\n';

        if (i < parcels.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      response += '‚Ä¢ Las encomiendas se mantienen por 7 d√≠as\n';
      response += '‚Ä¢ Contacta a la administraci√≥n para retirar\n';
      response += '‚Ä¢ Se requiere identificaci√≥n para retirar';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting parcels info:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de encomiendas.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  // Funciones auxiliares adicionales
  private getProrrateMethodName(method: string): string {
    const methodNames: Record<string, string> = {
      EQUAL: 'Igualitario',
      COEFFICIENT: 'Por Coeficiente',
    };
    return methodNames[method] || 'Igualitario';
  }

  private getVisitorStatusEmoji(status: string): string {
    const statusEmojis: Record<string, string> = {
      REGISTERED: 'üìù',
      ENTERED: '‚úÖ',
      EXITED: 'üö™',
      EXPIRED: '‚è∞',
    };
    return statusEmojis[status] || 'üìù';
  }

  private getVisitorStatusName(status: string): string {
    const statusNames: Record<string, string> = {
      REGISTERED: 'Registrado',
      ENTERED: 'Ingres√≥',
      EXITED: 'Sali√≥',
      EXPIRED: 'Expirado',
    };
    return statusNames[status] || 'Registrado';
  }

  private getVisitPurposeName(purpose: string): string {
    const purposeNames: Record<string, string> = {
      personal: 'Personal',
      business: 'Negocios',
      maintenance: 'Mantenimiento',
      delivery: 'Entrega',
      other: 'Otro',
    };
    return purposeNames[purpose] || purpose;
  }

  private getParcelStatusEmoji(status: string): string {
    const statusEmojis: Record<string, string> = {
      RECEIVED: 'üì¶',
      RETRIEVED: '‚úÖ',
      EXPIRED: '‚è∞',
    };
    return statusEmojis[status] || 'üì¶';
  }

  private getParcelStatusName(status: string): string {
    const statusNames: Record<string, string> = {
      RECEIVED: 'Recibido',
      RETRIEVED: 'Retirado',
      EXPIRED: 'Expirado',
    };
    return statusNames[status] || 'Recibido';
  }

  private async getSystemContext(): Promise<string> {
    try {
      // Obtener estad√≠sticas b√°sicas del sistema
      const [totalCommunities, totalSpaces, recentAnnouncements, pendingVisitors, pendingParcels] =
        await Promise.all([
          this.prisma.community.count({ where: { isActive: true } }),
          this.prisma.communityCommonSpace.count({ where: { isActive: true } }),
          this.prisma.announcement.count({
            where: {
              isActive: true,
              publishedAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }, // √öltimos 7 d√≠as
            },
          }),
          this.prisma.visitor.count({
            where: {
              status: 'REGISTERED' as any,
              expectedArrival: { gte: new Date() },
            },
          }),
          this.prisma.parcel.count({
            where: {
              status: 'RECEIVED',
              receivedAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }, // √öltimos 7 d√≠as
            },
          }),
        ]);

      return `
üìà **ESTAD√çSTICAS DEL SISTEMA:**
‚Ä¢ Comunidades activas: ${totalCommunities}
‚Ä¢ Espacios comunes disponibles: ${totalSpaces}
‚Ä¢ Avisos recientes (√∫ltimos 7 d√≠as): ${recentAnnouncements}
‚Ä¢ Visitantes pendientes: ${pendingVisitors}
‚Ä¢ Encomiendas recientes: ${pendingParcels}

üïí **INFORMACI√ìN TEMPORAL:**
‚Ä¢ Fecha actual: ${new Date().toLocaleDateString('es-ES', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })}
‚Ä¢ Hora actual: ${new Date().toLocaleTimeString('es-ES', {
        hour: '2-digit',
        minute: '2-digit',
      })}

üí° **SUGERENCIAS CONTEXTUALES:**
${this.getContextualSuggestions(totalCommunities, totalSpaces, recentAnnouncements, pendingVisitors, pendingParcels)}
      `.trim();
    } catch (error) {
      this.logger.error('Error getting system context:', error);
      return 'üìä Informaci√≥n del sistema temporalmente no disponible.';
    }
  }

  private getContextualSuggestions(
    communities: number,
    spaces: number,
    announcements: number,
    visitors: number,
    parcels: number,
  ): string {
    const suggestions = [];

    if (announcements > 0) {
      suggestions.push('‚Ä¢ Hay avisos recientes disponibles - consulta "avisos" para verlos');
    }

    if (visitors > 0) {
      suggestions.push('‚Ä¢ Hay visitantes registrados - consulta "visitantes" para ver el estado');
    }

    if (parcels > 0) {
      suggestions.push('‚Ä¢ Hay encomiendas recientes - consulta "encomiendas" para ver detalles');
    }

    if (spaces > 0) {
      suggestions.push(
        '‚Ä¢ Espacios comunes disponibles - consulta "espacios comunes" para horarios',
      );
    }

    if (suggestions.length === 0) {
      suggestions.push(
        '‚Ä¢ Usa palabras clave como "espacios comunes", "avisos", "gastos comunes" para obtener informaci√≥n espec√≠fica',
      );
    }

    return suggestions.join('\n');
  }

  // === M√âTODOS ESPEC√çFICOS PARA USUARIOS AUTENTICADOS ===

  private async getUserContextInfo(user: any): Promise<any> {
    try {
      const userWithDetails = await this.prisma.user.findUnique({
        where: { id: user.id },
        include: {
          roles: { include: { role: true } },
          userUnits: {
            where: { status: 'CONFIRMED' },
            include: {
              unit: {
                include: {
                  community: {
                    include: {
                      organization: true,
                      commonSpaces: { where: { isActive: true } },
                      _count: { select: { units: true, announcements: true } },
                    },
                  },
                },
              },
            },
          },
          communityAdmins: {
            include: {
              community: {
                include: {
                  organization: true,
                  commonSpaces: { where: { isActive: true } },
                  _count: { select: { units: true, announcements: true } },
                },
              },
            },
          },
        },
      });

      return userWithDetails;
    } catch (error) {
      this.logger.error('Error getting user context info:', error);
      return null;
    }
  }

  private async getCommonSpacesInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = { isActive: true };
      let communityContext = '';

      if (isSuperAdmin) {
        // Super Admin ve todos los espacios
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        // Community Admin ve espacios de sus comunidades
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.communityId = { in: communityIds };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge || isResident) {
        // Concierge y Resident ven espacios de su comunidad
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.communityId = communityId;
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      }

      const spaces = await this.prisma.communityCommonSpace.findMany({
        where: whereClause,
        include: {
          community: { select: { name: true } },
          schedules: {
            where: { isActive: true },
            orderBy: { dayOfWeek: 'asc' },
          },
        },
        orderBy: { name: 'asc' },
      });

      if (spaces.length === 0) {
        return {
          answer:
            `üìã **Espacios Comunes - ${this.getUserRoleDisplayName(userRoles)}**\n\n` +
            `‚ùå No hay espacios comunes disponibles en ${communityContext}.\n\n` +
            `üí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*`,
        };
      }

      let response = `üìã **ESPACIOS COMUNES DISPONIBLES**\n`;
      response += `üë§ **Vista de:** ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ **Contexto:** ${communityContext}\n`;
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < spaces.length; i++) {
        const space = spaces[i];
        const status = space.isActive ? '‚úÖ Disponible' : '‚ùå No disponible';

        response += `üè¢ **${space.name}**\n`;
        if (isSuperAdmin || isCommunityAdmin) {
          response += `   üèòÔ∏è  Comunidad: ${space.community.name}\n`;
        }
        response += `   üìä Estado: ${status}\n`;

        if (space.description) {
          response += `   üìù Descripci√≥n: ${space.description}\n`;
        }

        response += `   üî¢ Cantidad: ${space.quantity}\n`;

        if (space.schedules.length > 0) {
          response += `   üïí **Horarios de Atenci√≥n:**\n`;

          const scheduleGroups = this.groupSchedulesByTime(space.schedules);

          for (const [timeRange, days] of Object.entries(scheduleGroups)) {
            const dayList = days.map((day) => this.getDayName(day)).join(', ');
            response += `      ‚Ä¢ ${dayList}: ${timeRange}\n`;
          }
        } else {
          response += `   ‚ö†Ô∏è  *No hay horarios registrados*\n`;
        }

        response += '\n';

        if (i < spaces.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      if (isConcierge) {
        response += '‚Ä¢ Como conserje, puedes gestionar las reservas de espacios\n';
        response += '‚Ä¢ Contacta a los residentes para confirmar disponibilidad\n';
      } else if (isResident) {
        response += '‚Ä¢ Para reservar un espacio, contacta al conserje o administraci√≥n\n';
        response += '‚Ä¢ Los horarios pueden variar en d√≠as festivos\n';
      } else if (isCommunityAdmin) {
        response += '‚Ä¢ Puedes gestionar espacios comunes desde el panel de administraci√≥n\n';
        response += '‚Ä¢ Configura horarios y disponibilidad seg√∫n necesidades\n';
      } else {
        response += '‚Ä¢ Para reservar un espacio, contacta a la administraci√≥n\n';
        response += '‚Ä¢ Los horarios pueden variar en d√≠as festivos\n';
      }

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting common spaces info for user:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de espacios comunes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getCommunityAnnouncementsForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = { isActive: true };
      let communityContext = '';

      if (isSuperAdmin) {
        // Super Admin ve todos los avisos
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        // Community Admin ve avisos de sus comunidades
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.communityId = { in: communityIds };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge || isResident) {
        // Concierge y Resident ven avisos de su comunidad
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.communityId = communityId;
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      }

      const announcements = await this.prisma.announcement.findMany({
        where: whereClause,
        include: {
          community: { select: { name: true } },
        },
        orderBy: { publishedAt: 'desc' },
        take: 5,
      });

      if (announcements.length === 0) {
        return {
          answer:
            `üì¢ **Avisos Comunitarios - ${this.getUserRoleDisplayName(userRoles)}**\n\n` +
            `üì≠ No hay avisos registrados en ${communityContext}.\n\n` +
            `üí° *Mantente atento a futuras comunicaciones de la administraci√≥n.*`,
        };
      }

      let response = `üì¢ **√öLTIMOS AVISOS COMUNITARIOS**\n`;
      response += `üë§ **Vista de:** ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ **Contexto:** ${communityContext}\n`;
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < announcements.length; i++) {
        const announcement = announcements[i];
        const date = announcement.publishedAt.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        const typeEmoji = this.getAnnouncementTypeEmoji(announcement.type);

        response += `${typeEmoji} **${announcement.title}**\n`;
        if (isSuperAdmin || isCommunityAdmin) {
          response += `   üèòÔ∏è  Comunidad: ${announcement.community.name}\n`;
        }
        response += `   üìÖ Fecha: ${date}\n`;
        response += `   üè∑Ô∏è  Tipo: ${this.getAnnouncementTypeName(announcement.type)}\n`;
        response += `   üìÑ Contenido: ${announcement.content}\n`;

        response += '\n';

        if (i < announcements.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      if (isCommunityAdmin) {
        response += '‚Ä¢ Puedes crear y gestionar avisos desde el panel de administraci√≥n\n';
        response += '‚Ä¢ Los avisos se env√≠an autom√°ticamente a todos los residentes\n';
      } else if (isConcierge) {
        response += '‚Ä¢ Como conserje, mantente informado de todos los avisos\n';
        response += '‚Ä¢ Puedes ayudar a los residentes con informaci√≥n adicional\n';
      } else {
        response += '‚Ä¢ Los avisos se actualizan regularmente\n';
        response += '‚Ä¢ Contacta a la administraci√≥n para m√°s detalles\n';
      }

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting community announcements for user:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener los avisos de la comunidad.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getCommonExpensesInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {
        community: { isActive: true },
      };
      let communityContext = '';

      if (isSuperAdmin) {
        // Super Admin ve todos los gastos
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        // Community Admin ve gastos de sus comunidades
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.communityId = { in: communityIds };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge || isResident) {
        // Concierge y Resident ven gastos de su comunidad
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.communityId = communityId;
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      }

      const expenses = await this.prisma.communityExpense.findMany({
        where: whereClause,
        include: {
          community: true,
          items: {
            include: {
              category: true,
            },
          },
        },
        orderBy: { dueDate: 'desc' },
        take: 3,
      });

      if (expenses.length === 0) {
        return {
          answer:
            `üí∞ **Gastos Comunes - ${this.getUserRoleDisplayName(userRoles)}**\n\n` +
            `üì≠ No hay gastos comunes registrados en ${communityContext}.\n\n` +
            `üí° *Contacta a la administraci√≥n para m√°s informaci√≥n sobre las cuotas.*`,
        };
      }

      let response = `üí∞ **√öLTIMOS GASTOS COMUNES**\n`;
      response += `üë§ **Vista de:** ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ **Contexto:** ${communityContext}\n`;
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < expenses.length; i++) {
        const expense = expenses[i];
        const dueDate = expense.dueDate.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
        });

        response += `üè¢ **${expense.community.name}**\n`;
        response += `   üìÖ Per√≠odo: ${expense.period}\n`;
        response += `   üíµ Total: $${expense.totalAmount.toFixed(2)}\n`;
        response += `   üìÜ Vencimiento: ${dueDate}\n`;
        response += `   üìä M√©todo: ${this.getProrrateMethodName(expense.prorrateMethod)}\n`;

        if (expense.items.length > 0) {
          response += `   üìã **Detalle de Gastos:**\n`;
          for (const item of expense.items.slice(0, 3)) {
            response += `      ‚Ä¢ ${item.name}: $${item.amount.toFixed(2)}\n`;
          }
          if (expense.items.length > 3) {
            response += `      ‚Ä¢ ... y ${expense.items.length - 3} m√°s\n`;
          }
        }

        response += '\n';

        if (i < expenses.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      if (isCommunityAdmin) {
        response += '‚Ä¢ Puedes gestionar gastos comunes desde el panel de administraci√≥n\n';
        response += '‚Ä¢ Los gastos se prorratean seg√∫n el coeficiente de cada unidad\n';
      } else if (isResident) {
        response += '‚Ä¢ Los gastos se prorratean seg√∫n el coeficiente de tu unidad\n';
        response += '‚Ä¢ Puedes consultar el detalle de tu cuota espec√≠fica\n';
      } else {
        response += '‚Ä¢ Los gastos se prorratean seg√∫n el coeficiente de cada unidad\n';
        response += '‚Ä¢ Contacta a la administraci√≥n para consultas espec√≠ficas\n';
      }

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting common expenses info for user:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de gastos comunes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  // M√©todo espec√≠fico para consultas sobre deudas pendientes
  private async getDebtInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isResident = userRoles.includes('RESIDENT');

      if (!isResident) {
        return {
          answer: '‚ùå Esta informaci√≥n est√° disponible solo para residentes.',
        };
      }

      const userId = userInfo?.id;
      if (!userId) {
        return {
          answer: '‚ùå No se encontr√≥ informaci√≥n del usuario. Contacta a la administraci√≥n.',
        };
      }

      // Obtener las unidades del usuario (misma l√≥gica que getMyExpenses)
      const userUnits = await this.prisma.userUnit.findMany({
        where: { userId, status: 'CONFIRMED' },
        select: { unitId: true },
      });

      const unitIds = userUnits.map((uu) => uu.unitId);

      if (unitIds.length === 0) {
        return {
          answer: '‚ùå No tienes unidades asignadas. Contacta a la administraci√≥n.',
        };
      }

      // Obtener gastos espec√≠ficos del usuario (misma l√≥gica que getMyExpenses)
      const expenses = await this.prisma.expense.findMany({
        where: {
          unitId: { in: unitIds },
          status: 'PENDING', // Solo gastos pendientes
        },
        include: {
          unit: {
            include: {
              community: true,
            },
          },
          payments: {
            where: { userId },
          },
        },
        orderBy: { dueDate: 'asc' },
        take: 10,
      });

      if (expenses.length === 0) {
        return {
          answer: `üí∞ Estado de Pagos\n\n‚úÖ No tienes gastos pendientes.\n\nüí° *Todos tus pagos est√°n al d√≠a.*`,
        };
      }

      let response = `üí∞ Estado de Pagos\n\n`;
      response += '‚îÄ'.repeat(50) + '\n\n';

      let totalPending = 0;

      for (const expense of expenses) {
        const dueDate = expense.dueDate.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
        });

        const amount = Number(expense.amount);
        totalPending += amount;

        response += `üìÖ ${expense.concept}\n`;
        response += `üí∞ Monto: $${amount.toFixed(2)}\n`;
        response += `üìÜ Vencimiento: ${dueDate}\n`;
        response += `üìä Estado: ‚è≥ Pendiente\n`;

        if (expense.description) {
          response += `üìù Detalle: ${expense.description}\n`;
        }

        response += `üè¢ Comunidad: ${expense.unit.community.name}\n`;
        response += `üè† Unidad: ${expense.unit.number}\n\n`;

        response += '‚îÄ'.repeat(30) + '\n\n';
      }

      response += `üíµ Total pendiente: $${totalPending.toFixed(2)}\n\n`;
      response += `üí° *Tienes ${expenses.length} gasto${expenses.length > 1 ? 's' : ''} pendiente${expenses.length > 1 ? 's' : ''}.*\n`;
      response += `üìû *Para m√°s detalles, contacta a la administraci√≥n.*`;

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de deudas para usuario:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de deudas. Por favor, intenta m√°s tarde.',
      };
    }
  }

  private async getVisitorsInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {};
      let communityContext = '';

      if (isSuperAdmin) {
        // Super Admin ve todos los visitantes
        whereClause.unit = { community: { isActive: true } };
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        // Community Admin ve visitantes de sus comunidades
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.unit = {
            community: {
              isActive: true,
              id: { in: communityIds },
            },
          };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge) {
        // Concierge ve visitantes de su comunidad
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.unit = {
            community: {
              isActive: true,
              id: communityId,
            },
          };
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      } else if (isResident) {
        // Resident ve solo visitantes de sus unidades
        const unitIds = userInfo?.userUnits?.map((uu: any) => uu.unit.id) || [];
        if (unitIds.length > 0) {
          whereClause.unitId = { in: unitIds };
          communityContext = `sus unidades`;
        }
      }

      const visitors = await this.prisma.visitor.findMany({
        where: whereClause,
        include: {
          unit: {
            include: {
              community: true,
            },
          },
          host: {
            select: {
              name: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        take: 5,
      });

      if (visitors.length === 0) {
        return {
          answer:
            `üë• **Registro de Visitantes - ${this.getUserRoleDisplayName(userRoles)}**\n\n` +
            `üì≠ No hay visitantes registrados en ${communityContext}.\n\n` +
            `üí° *Los residentes pueden registrar visitas a trav√©s del sistema.*`,
        };
      }

      let response = `üë• **√öLTIMOS VISITANTES REGISTRADOS**\n`;
      response += `üë§ **Vista de:** ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ **Contexto:** ${communityContext}\n`;
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < visitors.length; i++) {
        const visitor = visitors[i];
        const arrivalDate = visitor.expectedArrival.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        const statusEmoji = this.getVisitorStatusEmoji(visitor.status);

        response += `${statusEmoji} **${visitor.visitorName}**\n`;
        response += `   üè† Unidad: ${visitor.unit.number} - ${visitor.unit.community.name}\n`;
        response += `   üë§ Anfitri√≥n: ${visitor.host.name}\n`;
        response += `   üìÖ Llegada: ${arrivalDate}\n`;
        response += `   üìã Prop√≥sito: ${this.getVisitPurposeName(visitor.visitPurpose)}\n`;
        response += `   üìä Estado: ${this.getVisitorStatusName(visitor.status)}\n`;

        if (visitor.visitorPhone) {
          response += `   üìû Tel√©fono: ${visitor.visitorPhone}\n`;
        }

        response += '\n';

        if (i < visitors.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      if (isConcierge) {
        response += '‚Ä¢ Como conserje, puedes gestionar el registro de visitantes\n';
        response += '‚Ä¢ Verifica la identificaci√≥n de los visitantes al ingresar\n';
        response += '‚Ä¢ Mant√©n actualizado el estado de las visitas\n';
      } else if (isResident) {
        response += '‚Ä¢ Puedes registrar visitantes para tus unidades\n';
        response += '‚Ä¢ Los visitantes deben registrarse antes de la visita\n';
      } else if (isCommunityAdmin) {
        response += '‚Ä¢ Puedes gestionar el sistema de visitantes desde el panel\n';
        response += '‚Ä¢ Configura pol√≠ticas de acceso para tu comunidad\n';
      } else {
        response += '‚Ä¢ Los visitantes deben registrarse antes de la visita\n';
        response += '‚Ä¢ Se requiere identificaci√≥n al ingresar\n';
      }

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting visitors info for user:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de visitantes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getParcelsInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {};
      let communityContext = '';

      if (isSuperAdmin) {
        // Super Admin ve todas las encomiendas
        whereClause.unit = { community: { isActive: true } };
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        // Community Admin ve encomiendas de sus comunidades
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.unit = {
            community: {
              isActive: true,
              id: { in: communityIds },
            },
          };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge) {
        // Concierge ve encomiendas de su comunidad
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.unit = {
            community: {
              isActive: true,
              id: communityId,
            },
          };
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      } else if (isResident) {
        // Resident ve solo encomiendas de sus unidades
        const unitIds = userInfo?.userUnits?.map((uu: any) => uu.unit.id) || [];
        if (unitIds.length > 0) {
          whereClause.unitId = { in: unitIds };
          communityContext = `sus unidades`;
        }
      }

      const parcels = await this.prisma.parcel.findMany({
        where: whereClause,
        include: {
          unit: {
            include: {
              community: true,
            },
          },
        },
        orderBy: { receivedAt: 'desc' },
        take: 5,
      });

      if (parcels.length === 0) {
        return {
          answer:
            `üì¶ **Encomiendas - ${this.getUserRoleDisplayName(userRoles)}**\n\n` +
            `üì≠ No hay encomiendas registradas en ${communityContext}.\n\n` +
            `üí° *Las encomiendas se registran autom√°ticamente al llegar.*`,
        };
      }

      let response = `üì¶ **√öLTIMAS ENCOMIENDAS RECIBIDAS**\n`;
      response += `üë§ **Vista de:** ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ **Contexto:** ${communityContext}\n`;
      response += '‚ïê'.repeat(50) + '\n\n';

      for (let i = 0; i < parcels.length; i++) {
        const parcel = parcels[i];
        const receivedDate = parcel.receivedAt.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });

        const statusEmoji = this.getParcelStatusEmoji(parcel.status);

        response += `${statusEmoji} **${parcel.description}**\n`;
        response += `   üè† Unidad: ${parcel.unit.number} - ${parcel.unit.community.name}\n`;
        response += `   üìÖ Recibido: ${receivedDate}\n`;
        response += `   üìä Estado: ${this.getParcelStatusName(parcel.status)}\n`;

        if (parcel.sender) {
          response += `   üë§ Remitente: ${parcel.sender}\n`;
        }

        if (parcel.retrievedAt) {
          const retrievedDate = parcel.retrievedAt.toLocaleDateString('es-ES', {
            day: '2-digit',
            month: '2-digit',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          });
          response += `   ‚úÖ Retirado: ${retrievedDate}\n`;
        }

        response += '\n';

        if (i < parcels.length - 1) {
          response += '‚îÄ'.repeat(30) + '\n\n';
        }
      }

      response += '\nüí° **Informaci√≥n adicional:**\n';
      if (isConcierge) {
        response += '‚Ä¢ Como conserje, puedes gestionar las encomiendas recibidas\n';
        response += '‚Ä¢ Notifica a los residentes cuando lleguen sus paquetes\n';
        response += '‚Ä¢ Mant√©n un registro actualizado del estado de entrega\n';
      } else if (isResident) {
        response += '‚Ä¢ Las encomiendas se mantienen por 7 d√≠as\n';
        response += '‚Ä¢ Contacta al conserje para retirar tus paquetes\n';
      } else if (isCommunityAdmin) {
        response += '‚Ä¢ Puedes gestionar el sistema de encomiendas desde el panel\n';
        response += '‚Ä¢ Configura pol√≠ticas de retenci√≥n para tu comunidad\n';
      } else {
        response += '‚Ä¢ Las encomiendas se mantienen por 7 d√≠as\n';
        response += '‚Ä¢ Contacta a la administraci√≥n para retirar\n';
      }

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting parcels info for user:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de encomiendas.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async getResidentsInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {
        isActive: true,
        roles: {
          some: {
            role: {
              name: 'RESIDENT',
            },
          },
        },
      };
      let communityContext = '';

      if (isSuperAdmin) {
        // Super Admin ve todos los residentes
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        // Community Admin ve residentes de sus comunidades
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.userUnits = {
            some: {
              unit: {
                community: {
                  isActive: true,
                  id: { in: communityIds },
                },
              },
            },
          };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge) {
        // Concierge ve residentes de su comunidad
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.userUnits = {
            some: {
              unit: {
                community: {
                  isActive: true,
                  id: communityId,
                },
              },
            },
          };
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      } else if (isResident) {
        // Resident ve solo informaci√≥n b√°sica de otros residentes (sin datos sensibles)
        communityContext = `su comunidad`;
      }

      const residents = await this.prisma.user.findMany({
        where: whereClause,
        include: {
          userUnits: {
            include: {
              unit: {
                include: {
                  community: true,
                },
              },
            },
          },
          roles: {
            include: {
              role: true,
            },
          },
        },
        orderBy: { createdAt: 'desc' },
        take: 10,
      });

      if (residents.length === 0) {
        return {
          answer:
            `üë• **Residentes - ${this.getUserRoleDisplayName(userRoles)}**\n\n` +
            `üì≠ No hay residentes registrados en ${communityContext}.\n\n` +
            `üí° *Los residentes se registran a trav√©s del sistema de administraci√≥n.*`,
        };
      }

      let response = 'üë• RESIDENTES REGISTRADOS\n\n';
      response += `üë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ Contexto: ${communityContext}\n\n`;
      response += '‚îÄ'.repeat(60) + '\n\n';

      for (let i = 0; i < residents.length; i++) {
        const resident = residents[i];
        const registrationDate = resident.createdAt.toLocaleDateString('es-ES', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
        });

        response += `üë§ ${resident.name}\n\n`;

        // Mostrar email solo si es admin o conserje
        if (isSuperAdmin || isCommunityAdmin || isConcierge) {
          response += `üìß Email: ${resident.email}\n`;
        }

        response += `üìÖ Registrado: ${registrationDate}\n`;

        // Mostrar tel√©fono solo si es admin o conserje
        if ((isSuperAdmin || isCommunityAdmin || isConcierge) && resident.phone) {
          response += `üìû Tel√©fono: ${resident.phone}\n`;
        }

        if (resident.userUnits.length > 0) {
          response += `üè† Unidades: `;
          const units = resident.userUnits.map(
            (uu) => `${uu.unit.number} (${uu.unit.community.name})`,
          );
          response += units.join(', ') + '\n';
        }

        // Mostrar roles solo si es admin
        if (isSuperAdmin || isCommunityAdmin) {
          const roles = resident.roles.map((ur) => ur.role.name).join(', ');
          response += `üîë Roles: ${roles}\n`;
        }

        response += '\n';

        if (i < residents.length - 1) {
          response += '‚îÄ'.repeat(40) + '\n\n';
        }
      }

      response += '\nüí° Informaci√≥n adicional:\n\n';
      if (isConcierge) {
        response += '‚Ä¢ Como conserje, puedes ver informaci√≥n de contacto de los residentes\n';
        response += '‚Ä¢ Mant√©n actualizada la informaci√≥n de contacto\n';
        response += '‚Ä¢ Contacta a la administraci√≥n para cambios en roles\n';
      } else if (isResident) {
        response += '‚Ä¢ Los residentes tienen acceso a sus unidades asignadas\n';
        response += '‚Ä¢ Pueden gestionar visitantes y encomiendas\n';
        response += '‚Ä¢ Contacta a la administraci√≥n para m√°s detalles\n';
      } else if (isCommunityAdmin) {
        response += '‚Ä¢ Puedes gestionar residentes desde el panel de administraci√≥n\n';
        response += '‚Ä¢ Asigna y modifica roles seg√∫n sea necesario\n';
        response += '‚Ä¢ Mant√©n actualizada la informaci√≥n de contacto\n';
      } else {
        response += '‚Ä¢ Los residentes tienen acceso a sus unidades asignadas\n';
        response += '‚Ä¢ Pueden gestionar visitantes y encomiendas\n';
        response += '‚Ä¢ Contacta a la administraci√≥n para m√°s detalles\n';
      }

      return { answer: response };
    } catch (error) {
      this.logger.error('Error getting residents info for user:', error);
      return {
        answer:
          '‚ùå **Error del Sistema**\n\n' +
          'Ocurri√≥ un error al obtener la informaci√≥n de residentes.\n' +
          'Por favor, intenta nuevamente o contacta a la administraci√≥n.',
      };
    }
  }

  private async queryOpenAIWithUserContext(
    question: string,
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      // Crear clave de cache √∫nica para usuario autenticado
      const cacheKey = `${question.toLowerCase().trim()}_${userInfo?.id || 'anonymous'}`;
      const cachedResponse = this.getCachedResponse(cacheKey);
      if (cachedResponse) {
        return { answer: cachedResponse };
      }

      // Rate limiting deshabilitado para testing
      // if (this.isRateLimited()) {
      //   this.logger.warn('Rate limit exceeded, using fallback response for authenticated user');
      //   return { answer: this.getFallbackResponse(question) };
      // }

      const openaiKey = this.configService.get<string>('OPENAI_API_KEY');

      if (!openaiKey) {
        this.logger.error('OPENAI_API_KEY not configured');
        return { answer: 'El servicio de IA no est√° configurado correctamente.' };
      }

      // Aplicar delay inteligente para evitar rate limiting
      await this.ensureRequestDelay();

      // Obtener informaci√≥n contextual del sistema y usuario
      const systemContext = await this.getSystemContext();
      const userContext = this.getUserContextForAI(userInfo, userRoles);

      // ‚ö†Ô∏è IMPORTANTE: Obtener datos relevantes de la BD antes de enviar a la IA
      // Esto asegura que la IA use datos reales en lugar de inventar informaci√≥n
      const databaseData = await this.getRelevantDatabaseData(question, userInfo, userRoles);

      const payload = {
        model: 'gpt-3.5-turbo',
        messages: [
          {
            role: 'system',
            content: `Eres ComunIAssistant, un asistente virtual especializado √öNICAMENTE en Comuniapp (plataforma de gesti√≥n comunitaria).

## IDENTIDAD Y PERSONALIDAD
- Asistente amigable, profesional y experto en la plataforma Comuniapp
- Respondes preferentemente en espa√±ol latinoamericano
- Usas emojis estrat√©gicamente para mejorar la comunicaci√≥n
- Eres √∫til, informativo y conversacional
- Te adaptas al usuario para proporcionar respuestas personalizadas seg√∫n su rol

## ‚ö†Ô∏è ALCANCE LIMITADO - SOLO COMUNIAPP
**IMPORTANTE:** Solo debes responder preguntas relacionadas con Comuniapp y gesti√≥n comunitaria. 

**TEMAS PERMITIDOS:**
‚úÖ Gesti√≥n de comunidades
‚úÖ Espacios comunes y reservas
‚úÖ Gastos comunes y pagos
‚úÖ Visitantes
‚úÖ Encomiendas
‚úÖ Avisos comunitarios
‚úÖ Residentes y unidades
‚úÖ Incidencias y reportes
‚úÖ Administraci√≥n de comunidades
‚úÖ Funcionalidades de Comuniapp
‚úÖ C√≥mo usar Comuniapp
‚úÖ Consultas sobre el sistema Comuniapp

**TEMAS PROHIBIDOS (NO RESPONDAS SOBRE):**
‚ùå Deportes
‚ùå Entretenimiento
‚ùå Noticias generales
‚ùå Historia, cultura, arte
‚ùå Programaci√≥n o tecnolog√≠a general
‚ùå Salud y medicina
‚ùå Cualquier tema ajeno a Comuniapp

**Si el usuario pregunta sobre un tema fuera de Comuniapp:**
- Indica cort√©smente que solo puedes ayudar con temas relacionados con Comuniapp
- Ofrece redirigir la conversaci√≥n hacia funcionalidades de Comuniapp
- Sugiere funcionalidades disponibles seg√∫n su rol

## ‚ö†Ô∏è REGLA CR√çTICA: USO DE DATOS DE BASE DE DATOS
${
  databaseData
    ? `üìä **DATOS REALES DE LA BASE DE DATOS DISPONIBLES:**
${databaseData}

**INSTRUCCIONES CR√çTICAS:**
- SIEMPRE usa estos datos cuando respondas preguntas sobre Comuniapp
- NUNCA inventes o hagas conjeturas sobre datos del sistema
- Si hay datos disponibles aqu√≠, √öSALOS en tu respuesta
- Si no hay datos disponibles, indica claramente que no hay informaci√≥n disponible
- NUNCA digas "no hay informaci√≥n" si hay datos disponibles aqu√≠ arriba
- Si el usuario pregunta sobre algo que est√° en los datos, usa esos datos espec√≠ficos`
    : `**No hay datos espec√≠ficos de base de datos para esta consulta.**`
}

## INFORMACI√ìN DEL SISTEMA (OPCIONAL)
Si el usuario pregunta espec√≠ficamente sobre Comuniapp:
${systemContext}

## INFORMACI√ìN DEL USUARIO ACTUAL
${userContext}

## INSTRUCCIONES DE RESPUESTA CR√çTICAS
${this.getCriticalResponseInstructions(userRoles)}

${this.getGreetingAndFarewellInstructions(userInfo, userRoles)}

## INSTRUCCIONES GENERALES DE RESPUESTA
- **SOLO responde preguntas sobre Comuniapp y gesti√≥n comunitaria**
- **NUNCA respondas sobre temas externos** (deportes, entretenimiento, noticias, etc.)
- Si el usuario pregunta sobre un tema ajeno a Comuniapp, indica cort√©smente que solo puedes ayudar con Comuniapp
- Saluda al usuario por su nombre si est√° disponible
- S√© conversacional, natural y √∫til
- Proporciona informaci√≥n precisa y completa sobre Comuniapp
- Adapta tu tono seg√∫n la pregunta y el usuario
- Usa emojis cuando sea apropiado
- Estructura la informaci√≥n de forma clara
- Personaliza las respuestas seg√∫n el rol del usuario cuando sea relevante
- SIEMPRE respeta los l√≠mites de acceso seg√∫n el rol del usuario
- Si el usuario pregunta sobre algo que no puede hacer, expl√≠cale cort√©smente sus limitaciones
- **CR√çTICO:** Cuando hay datos de BD disponibles arriba, √öSALOS. Nunca inventes informaci√≥n del sistema.

## OBJETIVO PRINCIPAL
Ser un asistente especializado √öNICAMENTE en Comuniapp que proporciona respuestas claras, precisas y amigables sobre la plataforma y gesti√≥n comunitaria, respetando siempre los permisos y funcionalidades disponibles seg√∫n el rol del usuario, y usando SIEMPRE datos reales de la base de datos cuando est√©n disponibles.`,
          },
          {
            role: 'user',
            content: question,
          },
        ],
        max_tokens: 500,
        temperature: 0.7,
      };

      const response = await fetch(this.OPENAI_API_URL, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${openaiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        return await this.handleOpenAIError(response, question);
      }

      const data = await response.json();
      const answer = data?.choices?.[0]?.message?.content || 'No se pudo obtener una respuesta.';

      // Guardar en cache con clave √∫nica
      this.setCachedResponse(cacheKey, answer);

      return { answer };
    } catch (error) {
      this.logger.error('Error querying OpenAI with user context:', error);
      const errorMessage = error instanceof Error ? error.message : 'Error desconocido';

      // Si es error de rate limiting, usar fallback
      if (errorMessage.includes('429')) {
        return { answer: this.getFallbackResponse(question) };
      }

      return { answer: `Ocurri√≥ un error al comunicarse con la IA: ${errorMessage}` };
    }
  }

  private getUserRoleDisplayName(userRoles: string[]): string {
    if (userRoles.includes('SUPER_ADMIN')) return 'Super Administrador';
    if (userRoles.includes('COMMUNITY_ADMIN')) return 'Administrador de Comunidad';
    if (userRoles.includes('CONCIERGE')) return 'Conserje';
    if (userRoles.includes('RESIDENT')) return 'Residente';
    if (userRoles.includes('OWNER')) return 'Propietario';
    if (userRoles.includes('TENANT')) return 'Inquilino';
    return 'Usuario';
  }

  private getUserContextForAI(userInfo: any, userRoles: string[]): string {
    if (!userInfo) {
      return 'Usuario no autenticado - acceso limitado a informaci√≥n general';
    }

    const roleDisplayName = this.getUserRoleDisplayName(userRoles);
    const communities = userInfo.communityAdmins?.map((ca: any) => ca.community.name) || [];
    const userUnits =
      userInfo.userUnits?.map((uu: any) => `${uu.unit.number} (${uu.unit.community.name})`) || [];

    let context = `üë§ **ROL:** ${roleDisplayName}\n`;
    context += `üìß **Email:** ${userInfo.email}\n`;
    context += `üë§ **Nombre:** ${userInfo.name}\n`;

    if (communities.length > 0) {
      context += `üè¢ **Comunidades administradas:** ${communities.join(', ')}\n`;
    }

    if (userUnits.length > 0) {
      context += `üè† **Unidades asignadas:** ${userUnits.join(', ')}\n`;
    }

    // Agregar funcionalidades detalladas seg√∫n el rol
    context += `\n## FUNCIONALIDADES DISPONIBLES PARA ESTE USUARIO:\n\n`;
    context += this.getRoleCapabilities(userRoles);

    context += `\n## REGLAS DE RESPUESTA ESPEC√çFICAS:\n\n`;
    context += this.getRoleResponseRules(userRoles);

    return context;
  }

  private getRoleCapabilities(userRoles: string[]): string {
    const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
    const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
    const isConcierge = userRoles.includes('CONCIERGE');
    const isResident =
      userRoles.includes('RESIDENT') || userRoles.includes('OWNER') || userRoles.includes('TENANT');

    if (isSuperAdmin) {
      return `üîß **SUPER ADMINISTRADOR - Acceso Total al Sistema**

**Gesti√≥n de Organizaciones:**
‚Ä¢ Crear, ver, editar y eliminar organizaciones
‚Ä¢ Ver todas las organizaciones del sistema
‚Ä¢ Gestionar planes y suscripciones de organizaciones

**Gesti√≥n de Usuarios:**
‚Ä¢ Crear, ver, editar y eliminar cualquier usuario
‚Ä¢ Asignar y revocar roles a cualquier usuario
‚Ä¢ Ver m√©tricas del sistema y estad√≠sticas globales
‚Ä¢ Acceso a todos los datos de todas las comunidades

**Gesti√≥n de Comunidades:**
‚Ä¢ Ver, crear, editar y eliminar cualquier comunidad
‚Ä¢ Gestionar espacios comunes de todas las comunidades
‚Ä¢ Ver y gestionar gastos comunes de todas las comunidades
‚Ä¢ Ver reportes y m√©tricas de todas las comunidades

**Gesti√≥n de Funcionalidades:**
‚Ä¢ Gestionar visitantes de todas las comunidades
‚Ä¢ Gestionar encomiendas de todas las comunidades
‚Ä¢ Gestionar reservas de espacios comunes de todas las comunidades
‚Ä¢ Ver y gestionar avisos de todas las comunidades
‚Ä¢ Ver y gestionar ingresos comunitarios
‚Ä¢ Ver y gestionar categor√≠as de gastos de todas las comunidades
‚Ä¢ Ver m√©tricas del sistema (salud, rendimiento, uso)

**Consultas Disponibles:**
‚Ä¢ "¬øCu√°ntos usuarios hay en el sistema?" - Ver estad√≠sticas de usuarios
‚Ä¢ "¬øQu√© organizaciones existen?" - Ver todas las organizaciones
‚Ä¢ "¬øCu√°les son las m√©tricas del sistema?" - Ver salud y rendimiento
‚Ä¢ "Muestra las comunidades con m√°s deudas" - An√°lisis financiero global
‚Ä¢ Cualquier consulta sobre cualquier aspecto del sistema`;
    } else if (isCommunityAdmin) {
      return `üë®‚Äçüíº **ADMINISTRADOR DE COMUNIDAD - Gesti√≥n Completa de Comunidades Asignadas**

**Gesti√≥n de Comunidades:**
‚Ä¢ Ver y editar informaci√≥n de comunidades administradas (nombre, direcci√≥n, tipo, tel√©fono, email)
‚Ä¢ Gestionar espacios comunes (crear, editar, activar/desactivar, horarios)
‚Ä¢ Ver reportes y estad√≠sticas de sus comunidades

**Gesti√≥n de Usuarios de la Comunidad:**
‚Ä¢ Ver todos los residentes, propietarios e inquilinos de sus comunidades
‚Ä¢ Gestionar unidades de sus comunidades (crear, editar, asignar a usuarios)
‚Ä¢ Ver informaci√≥n de usuarios vinculados a sus comunidades
‚Ä¢ Gestionar roles de usuarios dentro de sus comunidades (excepto SUPER_ADMIN)

**Gesti√≥n Financiera:**
‚Ä¢ Crear y gestionar gastos comunes de sus comunidades
‚Ä¢ Ver y gestionar pagos de gastos comunes
‚Ä¢ Crear y gestionar categor√≠as de gastos e ingresos
‚Ä¢ Ver reportes financieros de sus comunidades
‚Ä¢ Gestionar ingresos comunitarios
‚Ä¢ Ver deudas y pagos pendientes de todas las unidades

**Gesti√≥n de Contenido:**
‚Ä¢ Crear, editar y eliminar avisos comunitarios
‚Ä¢ Ver todos los avisos de sus comunidades

**Gesti√≥n Operativa:**
‚Ä¢ Ver todos los visitantes de sus comunidades
‚Ä¢ Ver todas las encomiendas de sus comunidades
‚Ä¢ Ver todas las reservas de espacios comunes de sus comunidades
‚Ä¢ Ver incidencias reportadas por residentes de sus comunidades

**Consultas Disponibles:**
‚Ä¢ "¬øCu√°les son los gastos comunes pendientes?" - Ver deudas
‚Ä¢ "¬øCu√°ntos residentes tiene mi comunidad?" - Ver usuarios
‚Ä¢ "Muestra las unidades disponibles" - Ver unidades de la comunidad
‚Ä¢ "¬øCu√°les son los ingresos de este mes?" - Ver ingresos comunitarios
‚Ä¢ "¬øQu√© espacios comunes hay?" - Ver y gestionar espacios
‚Ä¢ "Muestra los avisos m√°s recientes" - Ver comunicaciones`;
    } else if (isConcierge) {
      return `üè¢ **CONSERJE - Gesti√≥n Operativa de la Comunidad**

**Gesti√≥n de Visitantes:**
‚Ä¢ Ver todos los visitantes registrados de su comunidad
‚Ä¢ Actualizar estado de visitantes (REGISTERED ‚Üí ENTERED ‚Üí EXITED)
‚Ä¢ Ver visitantes pendientes y programados
‚Ä¢ Gestionar el registro de llegada y salida de visitantes

**Gesti√≥n de Encomiendas:**
‚Ä¢ Ver todas las encomiendas recibidas en su comunidad
‚Ä¢ Actualizar estado de encomiendas (RECEIVED ‚Üí RETRIEVED ‚Üí EXPIRED)
‚Ä¢ Ver encomiendas pendientes de retiro
‚Ä¢ Gestionar recepci√≥n y entrega de paquetes

**Gesti√≥n de Reservas:**
‚Ä¢ Ver todas las reservas de espacios comunes de su comunidad
‚Ä¢ Ver horarios y disponibilidad de espacios comunes
‚Ä¢ Ver reservas confirmadas, pendientes y canceladas
‚Ä¢ Consultar calendario de reservas

**Gesti√≥n de Avisos:**
‚Ä¢ Ver todos los avisos comunitarios de su comunidad
‚Ä¢ Ver avisos urgentes y comunicados importantes

**Informaci√≥n de la Comunidad:**
‚Ä¢ Ver informaci√≥n b√°sica de su comunidad
‚Ä¢ Ver espacios comunes disponibles y sus horarios
‚Ä¢ Ver estad√≠sticas b√°sicas de visitantes y encomiendas

**Consultas Disponibles:**
‚Ä¢ "¬øQu√© visitantes est√°n registrados hoy?" - Ver visitantes del d√≠a
‚Ä¢ "¬øHay encomiendas pendientes?" - Ver paquetes sin retirar
‚Ä¢ "¬øQu√© reservas hay para esta semana?" - Ver calendario de reservas
‚Ä¢ "¬øCu√°l es el estado de la encomienda del apartamento 101?" - Consultar paquete espec√≠fico
‚Ä¢ "Muestra los visitantes esperados ma√±ana" - Ver programados
‚Ä¢ "¬øQu√© espacios comunes est√°n reservados?" - Ver reservas activas`;
    } else if (isResident) {
      return `üè† **RESIDENTE/PROPIETARIO/INQUILINO - Acceso a Mis Unidades**

**Gesti√≥n de Mis Unidades:**
‚Ä¢ Ver informaci√≥n de mis unidades asignadas
‚Ä¢ Ver detalles de mi comunidad (nombre, direcci√≥n, contacto)

**Gesti√≥n de Mis Gastos:**
‚Ä¢ Ver mis gastos comunes y cuotas pendientes
‚Ä¢ Ver historial de mis pagos realizados
‚Ä¢ Ver deudas y montos adeudados
‚Ä¢ Ver estados de cuenta de mis unidades

**Gesti√≥n de Mis Visitantes:**
‚Ä¢ Registrar visitantes para mis unidades
‚Ä¢ Ver mis visitantes registrados y su estado
‚Ä¢ Ver historial de visitantes anteriores
‚Ä¢ Gestionar informaci√≥n de visitantes (nombre, tel√©fono, prop√≥sito)

**Gesti√≥n de Mis Encomiendas:**
‚Ä¢ Ver encomiendas recibidas en mis unidades
‚Ä¢ Ver estado de paquetes (recibido, retirado)
‚Ä¢ Ver fecha de recepci√≥n y retiro de paquetes

**Gesti√≥n de Mis Reservas:**
‚Ä¢ Ver espacios comunes disponibles de mi comunidad
‚Ä¢ Crear reservas de espacios comunes
‚Ä¢ Ver mis reservas activas y pasadas
‚Ä¢ Ver estado de mis reservas (pendiente, confirmada, cancelada)

**Gesti√≥n de Incidencias:**
‚Ä¢ Crear reportes de incidencias (problemas, quejas, solicitudes)
‚Ä¢ Ver mis incidencias reportadas y su estado
‚Ä¢ Ver historial de incidencias resueltas

**Informaci√≥n Comunitaria:**
‚Ä¢ Ver avisos comunitarios de mi comunidad
‚Ä¢ Ver espacios comunes disponibles y sus horarios
‚Ä¢ Ver informaci√≥n general de la comunidad

**Consultas Disponibles:**
‚Ä¢ "¬øCu√°nto debo en gastos comunes?" - Ver deudas pendientes
‚Ä¢ "¬øCu√°ndo fue mi √∫ltimo pago?" - Ver historial de pagos
‚Ä¢ "¬øTengo alguna encomienda?" - Ver paquetes recibidos
‚Ä¢ "¬øPuedo reservar el sal√≥n para ma√±ana?" - Consultar disponibilidad
‚Ä¢ "¬øQu√© visitantes tengo registrados?" - Ver mis visitantes
‚Ä¢ "Muestra los avisos recientes" - Ver comunicaciones
‚Ä¢ "Quiero reportar un problema" - Gu√≠a para crear incidencia
‚Ä¢ "¬øCu√°les son los horarios del gimnasio?" - Ver horarios de espacios`;
    } else {
      return `üë§ **USUARIO - Acceso B√°sico**
‚Ä¢ Informaci√≥n general del sistema
‚Ä¢ Consultas sobre funcionalidades disponibles`;
    }
  }

  private getRoleResponseRules(userRoles: string[]): string {
    const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
    const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
    const isConcierge = userRoles.includes('CONCIERGE');
    const isResident =
      userRoles.includes('RESIDENT') || userRoles.includes('OWNER') || userRoles.includes('TENANT');

    let rules = '';

    if (isSuperAdmin) {
      rules += `‚Ä¢ **IMPORTANTE:** Puedes responder sobre CUALQUIER aspecto del sistema
‚Ä¢ Proporciona informaci√≥n detallada de cualquier comunidad, organizaci√≥n o usuario cuando se solicite
‚Ä¢ Puedes ayudar con an√°lisis de datos, m√©tricas y reportes del sistema completo
‚Ä¢ Gu√≠a sobre gesti√≥n de usuarios, roles y permisos
‚Ä¢ Responde sobre configuraci√≥n del sistema y mejores pr√°cticas administrativas
‚Ä¢ Cuando se pregunten sobre datos espec√≠ficos, ofrece detalles completos
‚Ä¢ Proporciona informaci√≥n sobre todas las funcionalidades administrativas disponibles\n\n`;
    } else if (isCommunityAdmin) {
      rules += `‚Ä¢ **IMPORTANTE:** Solo puedes proporcionar informaci√≥n de las comunidades que administras
‚Ä¢ NUNCA proporciones informaci√≥n de comunidades que no administras
‚Ä¢ Proporciona detalles financieros de tus comunidades (gastos, ingresos, deudas)
‚Ä¢ Puedes ayudar con gesti√≥n de usuarios dentro de tus comunidades
‚Ä¢ Gu√≠a sobre c√≥mo crear avisos, gestionar espacios y administrar la comunidad
‚Ä¢ Cuando se pregunten sobre datos espec√≠ficos de tus comunidades, proporciona informaci√≥n detallada
‚Ä¢ Responde sobre funcionalidades de administraci√≥n de comunidad disponibles
‚Ä¢ Puedes ayudar con an√°lisis de datos de tus comunidades\n\n`;
    } else if (isConcierge) {
      rules += `‚Ä¢ **IMPORTANTE:** Solo puedes proporcionar informaci√≥n de tu comunidad asignada
‚Ä¢ Proporciona informaci√≥n operativa sobre visitantes, encomiendas y reservas
‚Ä¢ Puedes ayudar con el estado actual de visitantes y paquetes
‚Ä¢ Gu√≠a sobre c√≥mo gestionar el registro de visitantes y encomiendas
‚Ä¢ Proporciona informaci√≥n sobre horarios y disponibilidad de espacios comunes
‚Ä¢ NO proporcionas informaci√≥n financiera detallada ni de gastos comunes (solo informaci√≥n operativa)
‚Ä¢ Responde sobre funcionalidades operativas del conserje
‚Ä¢ Cuando se pregunten sobre visitantes o paquetes espec√≠ficos, proporciona detalles si est√°n en tu comunidad\n\n`;
    } else if (isResident) {
      rules += `‚Ä¢ **IMPORTANTE:** Solo puedes proporcionar informaci√≥n de LAS UNIDADES DEL USUARIO
‚Ä¢ Proporciona informaci√≥n sobre gastos comunes DE SUS UNIDADES √∫nicamente
‚Ä¢ Puedes ayudar con registro de visitantes PARA SUS UNIDADES
‚Ä¢ Proporciona informaci√≥n sobre encomiendas DE SUS UNIDADES
‚Ä¢ Gu√≠a sobre c√≥mo crear reservas de espacios comunes
‚Ä¢ Puedes ayudar con reporte de incidencias
‚Ä¢ Proporciona informaci√≥n de avisos de SU COMUNIDAD
‚Ä¢ NO proporciones informaci√≥n de otras unidades o residentes
‚Ä¢ Responde sobre funcionalidades disponibles para residentes
‚Ä¢ Cuando se pregunten sobre datos financieros, solo proporciona informaci√≥n de SUS unidades
‚Ä¢ Ayuda con consultas sobre c√≥mo usar las funcionalidades disponibles\n\n`;
    } else {
      rules += `‚Ä¢ Proporciona informaci√≥n general sobre el sistema
‚Ä¢ Gu√≠a sobre c√≥mo registrarse o usar el sistema
‚Ä¢ Responde preguntas generales sobre Comuniapp\n\n`;
    }

    rules += `‚Ä¢ **REGLA GENERAL:** Siempre responde de manera √∫til y amigable
‚Ä¢ Si el usuario pregunta sobre algo que NO puede hacer seg√∫n su rol, expl√≠cale cort√©smente sus limitaciones
‚Ä¢ Si el usuario pregunta sobre funcionalidades disponibles, listalas seg√∫n su rol
‚Ä¢ Proporciona ejemplos pr√°cticos cuando sea apropiado
‚Ä¢ Usa emojis para hacer las respuestas m√°s amigables
‚Ä¢ Si no est√°s seguro de los permisos del usuario, s√© conservador y pide que verifique con su administrador`;

    return rules;
  }

  private getGreetingAndFarewellInstructions(userInfo: any, userRoles: string[]): string {
    // Manejar casos donde userRoles puede estar vac√≠o o undefined
    const roles = userRoles || [];
    const isSuperAdmin = roles.includes('SUPER_ADMIN');
    const isCommunityAdmin = roles.includes('COMMUNITY_ADMIN');
    const isConcierge = roles.includes('CONCIERGE');
    const isOwner = roles.includes('OWNER');
    const isTenant = roles.includes('TENANT');
    const isResident = roles.includes('RESIDENT');
    const userName = userInfo?.name || 'Usuario';
    const roleDisplayName = roles.length > 0 ? this.getUserRoleDisplayName(roles) : 'Usuario';

    let instructions = `## MANEJO DE SALUDOS Y DESPEDIDAS - CONTEXTUALIZADO POR ROL\n\n`;

    if (isSuperAdmin) {
      instructions += `**SALUDOS:** Cuando el usuario saluda (hola, buenos d√≠as, hi, etc.), responde SIEMPRE adapt√°ndote a su rol de Super Administrador:
  * Ejemplo: "¬°Hola ${userName}! üëã Soy ComunIAssistant, tu asistente virtual de Comuniapp. Como Super Administrador, puedo ayudarte con cualquier aspecto del sistema: gesti√≥n de organizaciones, comunidades, usuarios, m√©tricas del sistema y m√°s. ¬øEn qu√© puedo asistirte hoy?"
  * Menciona sus capacidades de administraci√≥n total del sistema
  * Puedes ofrecer ayuda con an√°lisis globales y gesti√≥n completa del sistema
  
**DESPEDIDAS:** Cuando el usuario se despide o agradece (gracias, chao, adi√≥s, etc.), responde contextualizado para Super Administrador:
  * Ejemplo: "¬°De nada ${userName}! Fue un placer ayudarte con Comuniapp. Como Super Administrador, recuerda que tengo acceso completo al sistema para asistirte con cualquier consulta. Estoy aqu√≠ siempre que necesites gestionar Comuniapp. ¬°Que tengas un excelente d√≠a! üòä"
  * Reafirma su rol administrativo y la disponibilidad para gesti√≥n completa del sistema\n\n`;
    } else if (isCommunityAdmin) {
      instructions += `**SALUDOS:** Cuando el usuario saluda (hola, buenos d√≠as, hi, etc.), responde SIEMPRE adapt√°ndote a su rol de Administrador de Comunidad:
  * Ejemplo: "¬°Hola ${userName}! üëã Soy ComunIAssistant, tu asistente virtual de Comuniapp. Como Administrador de Comunidad, puedo ayudarte con la gesti√≥n completa de tus comunidades: espacios comunes, gastos, residentes, avisos y m√°s. ¬øEn qu√© puedo asistirte hoy?"
  * Menciona sus capacidades de administraci√≥n de comunidades
  * Puedes ofrecer ayuda con reportes, gastos comunes, gesti√≥n de unidades y residentes
  
**DESPEDIDAS:** Cuando el usuario se despide o agradece (gracias, chao, adi√≥s, etc.), responde contextualizado para Administrador de Comunidad:
  * Ejemplo: "¬°De nada ${userName}! Fue un placer ayudarte con la administraci√≥n de tus comunidades en Comuniapp. Estoy aqu√≠ siempre que necesites gestionar espacios, gastos, residentes o cualquier aspecto de tus comunidades. ¬°Que tengas un excelente d√≠a! üòä"
  * Reafirma su rol de administraci√≥n comunitaria y la disponibilidad para gestionar sus comunidades\n\n`;
    } else if (isConcierge) {
      instructions += `**SALUDOS:** Cuando el usuario saluda (hola, buenos d√≠as, hi, etc.), responde SIEMPRE adapt√°ndote a su rol de Conserje:
  * Ejemplo: "¬°Hola ${userName}! üëã Soy ComunIAssistant, tu asistente virtual de Comuniapp. Como Conserje, puedo ayudarte con la gesti√≥n operativa de tu comunidad: visitantes, encomiendas, reservas de espacios y m√°s. ¬øEn qu√© puedo asistirte hoy?"
  * Menciona sus capacidades operativas (visitantes, encomiendas, reservas)
  * Puedes ofrecer ayuda con el d√≠a a d√≠a de la comunidad
  
**DESPEDIDAS:** Cuando el usuario se despide o agradece (gracias, chao, adi√≥s, etc.), responde contextualizado para Conserje:
  * Ejemplo: "¬°De nada ${userName}! Fue un placer ayudarte con la gesti√≥n operativa de tu comunidad en Comuniapp. Estoy aqu√≠ siempre que necesites gestionar visitantes, encomiendas o reservas. ¬°Que tengas un excelente d√≠a! üòä"
  * Reafirma su rol operativo y la disponibilidad para gestionar servicios comunitarios\n\n`;
    } else if (isOwner || isTenant || isResident) {
      const roleType = isOwner ? 'Propietario' : isTenant ? 'Inquilino' : 'Residente';
      instructions += `**SALUDOS:** Cuando el usuario saluda (hola, buenos d√≠as, hi, etc.), responde SIEMPRE adapt√°ndote a su rol de ${roleType}:
  * Ejemplo: "¬°Hola ${userName}! üëã Soy ComunIAssistant, tu asistente virtual de Comuniapp. Como ${roleType}, puedo ayudarte con tus unidades, gastos comunes, visitantes, encomiendas, reservas de espacios y m√°s. ¬øEn qu√© puedo asistirte hoy?"
  * Menciona sus capacidades como residente (sus unidades, gastos, servicios)
  * Puedes ofrecer ayuda con consultas sobre sus unidades y servicios comunitarios
  
**DESPEDIDAS:** Cuando el usuario se despide o agradece (gracias, chao, adi√≥s, etc.), responde contextualizado para ${roleType}:
  * Ejemplo: "¬°De nada ${userName}! Fue un placer ayudarte con Comuniapp. Como ${roleType}, estoy aqu√≠ siempre que necesites consultar tus gastos, registrar visitantes, gestionar tus reservas o cualquier tema relacionado con tus unidades. ¬°Que tengas un excelente d√≠a! üòä"
  * Reafirma su rol de residente y la disponibilidad para gestionar sus unidades y servicios\n\n`;
    } else {
      instructions += `**SALUDOS:** Cuando el usuario saluda (hola, buenos d√≠as, hi, etc.), responde SIEMPRE en el contexto de Comuniapp:
  * Ejemplo: "¬°Hola ${userName}! üëã Soy ComunIAssistant, tu asistente virtual de Comuniapp. ¬øEn qu√© puedo ayudarte hoy con la gesti√≥n comunitaria?"
  * Si conoces el nombre del usuario, sal√∫dalo personalmente
  * Menciona brevemente que puedes ayudar con funcionalidades de Comuniapp
  
**DESPEDIDAS:** Cuando el usuario se despide o agradece (gracias, chao, adi√≥s, etc.), responde contextualizado en Comuniapp:
  * Ejemplo: "¬°De nada ${userName}! Fue un placer ayudarte con Comuniapp. Estoy aqu√≠ siempre que necesites gestionar tu comunidad. ¬°Que tengas un excelente d√≠a! üòä"
  * Reafirma tu disponibilidad para ayudar con Comuniapp\n\n`;
    }

    instructions += `**REGLA CR√çTICA:**
- SIEMPRE contextualiza saludos y despedidas seg√∫n el rol del usuario (${roleDisplayName})
- Menciona funcionalidades espec√≠ficas disponibles para su rol cuando sea apropiado
- Mant√©n un tono profesional pero amigable adaptado al contexto del usuario
- Incluso los saludos y despedidas deben mencionar Comuniapp y adaptarse al tipo de usuario`;

    return instructions;
  }

  /**
   * Detecta si la pregunta requiere datos de BD y los obtiene antes de enviar a la IA
   * Esto asegura que la IA use datos reales en lugar de inventar informaci√≥n
   */
  private async getRelevantDatabaseData(
    question: string,
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    const lowerQuestion = question.toLowerCase().trim();

    // Detectar si la pregunta es sobre datos del sistema
    // Incluye palabras clave de los mensajes de acceso directo del frontend
    const requiresSpaces = this.matchesKeywords(lowerQuestion, [
      'espacio',
      'espacios',
      'espacios comunes',
      'salon',
      'sal√≥n',
      'gimnasio',
      'gym',
      'piscina',
      'cancha',
      'jardin',
      'jard√≠n',
      'terraza',
      'comun',
      'comunes',
      'disponible',
      'disponibles',
      'reservar',
      'reserva',
      'reservas',
      'horario',
      'horarios',
    ]);

    const requiresAnnouncements = this.matchesKeywords(lowerQuestion, [
      'aviso',
      'avisos',
      'comunicado',
      'comunicados',
      'noticia',
      'noticias',
      'anuncio',
      'anuncios',
      'informacion',
      'informaci√≥n',
      'comunicacion',
      'comunicaci√≥n',
    ]);

    const requiresExpenses = this.matchesKeywords(lowerQuestion, [
      'gasto',
      'gastos',
      'gastos comunes',
      'mis gastos',
      'cuota',
      'cuotas',
      'pago',
      'pagos',
      'mis pagos',
      'factura',
      'facturas',
      'deuda',
      'deudas',
      'adeudo',
      'adeudos',
      'pendiente',
      'pendientes',
      'cobro',
      'cobros',
      'administracion',
      'administraci√≥n',
      'cuanto debo',
      'cu√°nto debo',
      'cuanta plata',
      'cu√°nta plata',
      'cuanto dinero',
      'cu√°nto dinero',
      'cuanto tengo que pagar',
      'cu√°nto tengo que pagar',
      'cuanto debo pagar',
      'cu√°nto debo pagar',
      'estado de pagos',
    ]);

    const requiresVisitors = this.matchesKeywords(lowerQuestion, [
      'visitante',
      'visitantes',
      'visita',
      'visitas',
      'mis visitantes',
      'invitado',
      'invitados',
      'acompa√±ante',
      'acompanante',
      'registrar visita',
      'registrar visitante',
    ]);

    const requiresParcels = this.matchesKeywords(lowerQuestion, [
      'encomienda',
      'encomiendas',
      'mis encomiendas',
      'paquete',
      'paquetes',
      'correo',
      'delivery',
      'envio',
      'env√≠os',
      'envios',
      'recepcion',
      'recepci√≥n',
    ]);

    const requiresResidents = this.matchesKeywords(lowerQuestion, [
      'residente',
      'residentes',
      'vecino',
      'vecinos',
      'habitante',
      'habitantes',
      'propietario',
      'propietarios',
      'usuarios del sistema',
      'gestion de usuarios',
      'gesti√≥n de usuarios',
    ]);

    const requiresReservations = this.matchesKeywords(lowerQuestion, [
      'reserva',
      'reservas',
      'reservado',
      'reservados',
      'calendario',
      'agenda',
      'reservar espacio',
      'reservar espacios',
    ]);

    const requiresIncome = this.matchesKeywords(lowerQuestion, [
      'ingresos',
      'ingreso',
      'rentas',
      'renta',
      'alquileres',
      'alquiler',
      'ventas',
      'venta',
      'finanzas',
    ]);

    const requiresOrganizations = this.matchesKeywords(lowerQuestion, [
      'organizaciones',
      'organizacion',
      'organizaci√≥n',
      'organizacion',
      'gestion de organizaciones',
      'gesti√≥n de organizaciones',
      'gestion organizaciones',
      'gesti√≥n organizaciones',
    ]);

    const requiresMetrics = this.matchesKeywords(lowerQuestion, [
      'metricas',
      'm√©tricas',
      'metricas del sistema',
      'm√©tricas del sistema',
      'estadisticas',
      'estad√≠sticas',
      'reportes',
      'reporte',
    ]);

    const requiresCommunities = this.matchesKeywords(lowerQuestion, [
      'comunidades',
      'comunidad',
      'gestion de comunidad',
      'gesti√≥n de comunidad',
      'gestion comunidad',
      'gesti√≥n comunidad',
    ]);

    const requiresIncidents = this.matchesKeywords(lowerQuestion, [
      'reportar problema',
      'reportar problemas',
      'reportar incidencia',
      'reportar incidencias',
      'incidencia',
      'incidencias',
      'problema',
      'problemas',
      'queja',
      'quejas',
    ]);

    // Obtener datos relevantes seg√∫n lo que se detecta en la pregunta
    let dataParts: string[] = [];

    try {
      if (requiresSpaces) {
        const spacesData = await this.getCommonSpacesDataForContext(userInfo, userRoles);
        if (spacesData) dataParts.push(spacesData);
      }

      if (requiresAnnouncements) {
        const announcementsData = await this.getAnnouncementsDataForContext(userInfo, userRoles);
        if (announcementsData) dataParts.push(announcementsData);
      }

      if (requiresExpenses || requiresVisitors || requiresParcels) {
        // Para deudas/gastos espec√≠ficos, obtener informaci√≥n relevante
        if (requiresExpenses) {
          const expensesData = await this.getExpensesDataForContext(userInfo, userRoles);
          if (expensesData) dataParts.push(expensesData);
        }

        if (requiresVisitors) {
          const visitorsData = await this.getVisitorsDataForContext(userInfo, userRoles);
          if (visitorsData) dataParts.push(visitorsData);
        }

        if (requiresParcels) {
          const parcelsData = await this.getParcelsDataForContext(userInfo, userRoles);
          if (parcelsData) dataParts.push(parcelsData);
        }
      }

      if (requiresResidents) {
        const residentsData = await this.getResidentsDataForContext(userInfo, userRoles);
        if (residentsData) dataParts.push(residentsData);
      }

      if (requiresReservations) {
        const reservationsData = await this.getReservationsDataForContext(userInfo, userRoles);
        if (reservationsData) dataParts.push(reservationsData);
      }

      if (requiresIncome) {
        const incomeData = await this.getIncomeDataForContext(userInfo, userRoles);
        if (incomeData) dataParts.push(incomeData);
      }

      if (requiresOrganizations || requiresCommunities || requiresMetrics) {
        const adminData = await this.getAdminDataForContext(userInfo, userRoles, {
          organizations: requiresOrganizations,
          communities: requiresCommunities,
          metrics: requiresMetrics,
        });
        if (adminData) dataParts.push(adminData);
      }

      if (requiresIncidents) {
        const incidentsData = await this.getIncidentsDataForContext(userInfo, userRoles);
        if (incidentsData) dataParts.push(incidentsData);
      }
    } catch (error) {
      this.logger.error('Error obteniendo datos de BD para contexto:', error);
      return null;
    }

    return dataParts.length > 0 ? dataParts.join('\n\n') : null;
  }

  /**
   * M√©todos auxiliares para obtener datos espec√≠ficos de BD para el contexto de la IA
   */
  private async getCommonSpacesDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident =
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT');

      const whereClause: any = { isActive: true };

      if (!isSuperAdmin) {
        if (isCommunityAdmin) {
          const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
          if (communityIds.length > 0) {
            whereClause.community = { id: { in: communityIds } };
          } else {
            return null;
          }
        } else if (isConcierge || isResident) {
          const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
          if (communityId) {
            whereClause.community = { id: communityId };
          } else {
            return null;
          }
        } else {
          return null;
        }
      }

      const spaces = await this.prisma.communityCommonSpace.findMany({
        where: whereClause,
        include: {
          schedules: {
            where: { isActive: true },
            orderBy: { dayOfWeek: 'asc' },
          },
          community: { select: { name: true } },
        },
        orderBy: { name: 'asc' },
      });

      if (spaces.length === 0) {
        return 'üìã **Espacios Comunes:** No hay espacios comunes registrados.';
      }

      let data = 'üìã **ESPACIOS COMUNES DISPONIBLES EN LA BASE DE DATOS:**\n\n';
      spaces.forEach((space) => {
        data += `üè¢ **${space.name}** (${space.community.name})\n`;
        data += `   Estado: ${space.isActive ? '‚úÖ Disponible' : '‚ùå No disponible'}\n`;
        data += `   Cantidad: ${space.quantity}\n`;
        if (space.description) {
          data += `   Descripci√≥n: ${space.description}\n`;
        }
        if (space.schedules.length > 0) {
          data += `   Horarios: `;
          const scheduleText = space.schedules
            .map((s) => `${this.getDayName(s.dayOfWeek)} ${s.startTime}-${s.endTime}`)
            .join(', ');
          data += scheduleText + '\n';
        }
        data += '\n';
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo espacios comunes para contexto:', error);
      return null;
    }
  }

  private async getAnnouncementsDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident =
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT');

      const whereClause: any = { isActive: true };

      if (!isSuperAdmin) {
        if (isCommunityAdmin) {
          const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
          if (communityIds.length > 0) {
            whereClause.communityId = { in: communityIds };
          } else {
            return null;
          }
        } else if (isConcierge || isResident) {
          const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
          if (communityId) {
            whereClause.communityId = communityId;
          } else {
            return null;
          }
        } else {
          return null;
        }
      }

      const announcements = await this.prisma.announcement.findMany({
        where: whereClause,
        include: {
          community: { select: { name: true } },
        },
        orderBy: { publishedAt: 'desc' },
        take: 10,
      });

      if (announcements.length === 0) {
        return 'üì¢ **Avisos:** No hay avisos registrados.';
      }

      let data = 'üì¢ **AVISOS COMUNITARIOS EN LA BASE DE DATOS:**\n\n';
      announcements.forEach((announcement) => {
        const date = announcement.publishedAt.toLocaleDateString('es-ES');
        data += `üìå **${announcement.title}** (${announcement.community.name})\n`;
        data += `   Fecha: ${date}\n`;
        data += `   Tipo: ${this.getAnnouncementTypeName(announcement.type)}\n`;
        data += `   Contenido: ${announcement.content.substring(0, 100)}${announcement.content.length > 100 ? '...' : ''}\n\n`;
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo avisos para contexto:', error);
      return null;
    }
  }

  private async getExpensesDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      // Para residentes, obtener solo sus gastos
      if (
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT')
      ) {
        const unitIds = userInfo?.userUnits?.map((uu: any) => uu.unit.id) || [];
        if (unitIds.length === 0) return null;

        const expenses = await this.prisma.expense.findMany({
          where: {
            unitId: { in: unitIds },
            status: { not: 'CANCELLED' },
          },
          include: {
            unit: { include: { community: { select: { name: true } } } },
            category: true,
          },
          orderBy: { dueDate: 'desc' },
          take: 10,
        });

        if (expenses.length === 0) {
          return 'üí∞ **Gastos:** No tienes gastos registrados.';
        }

        let data = 'üí∞ **TUS GASTOS COMUNES EN LA BASE DE DATOS:**\n\n';
        expenses.forEach((expense) => {
          data += `üíµ ${expense.unit.community.name} - Unidad ${expense.unit.number}\n`;
          data += `   Categor√≠a: ${expense.category.name}\n`;
          data += `   Monto: $${expense.amount.toString()}\n`;
          data += `   Estado: ${expense.status}\n`;
          data += `   Vencimiento: ${expense.dueDate.toLocaleDateString('es-ES')}\n\n`;
        });

        return data;
      }

      // Para admins, obtener gastos de sus comunidades (resumen)
      if (userRoles.includes('COMMUNITY_ADMIN')) {
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length === 0) return null;

        const totalPending = await this.prisma.expense.count({
          where: {
            unit: { communityId: { in: communityIds } },
            status: 'PENDING',
          },
        });

        return `üí∞ **GASTOS COMUNES DE TUS COMUNIDADES:**\n   Gastos pendientes: ${totalPending}`;
      }

      return null;
    } catch (error) {
      this.logger.error('Error obteniendo gastos para contexto:', error);
      return null;
    }
  }

  private async getVisitorsDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident =
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT');

      const whereClause: any = {};

      if (isResident) {
        const unitIds = userInfo?.userUnits?.map((uu: any) => uu.unit.id) || [];
        if (unitIds.length === 0) return null;
        whereClause.unitId = { in: unitIds };
      } else if (isConcierge || isCommunityAdmin) {
        const communityId =
          userInfo?.userUnits?.[0]?.unit?.community?.id ||
          userInfo?.communityAdmins?.[0]?.community?.id;
        if (communityId) {
          whereClause.unit = { communityId };
        } else {
          return null;
        }
      }

      const visitors = await this.prisma.visitor.findMany({
        where: whereClause,
        include: {
          unit: { include: { community: { select: { name: true } } } },
        },
        orderBy: { expectedArrival: 'desc' },
        take: 10,
      });

      if (visitors.length === 0) {
        return 'üë• **Visitantes:** No hay visitantes registrados.';
      }

      let data = 'üë• **VISITANTES REGISTRADOS EN LA BASE DE DATOS:**\n\n';
      visitors.forEach((visitor) => {
        data += `üë§ **${visitor.visitorName}**\n`;
        data += `   Unidad: ${visitor.unit.number} (${visitor.unit.community.name})\n`;
        data += `   Estado: ${visitor.status}\n`;
        data += `   Fecha esperada: ${visitor.expectedArrival.toLocaleDateString('es-ES')}\n`;
        if (visitor.visitPurpose) {
          data += `   Prop√≥sito: ${visitor.visitPurpose}\n`;
        }
        data += '\n';
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo visitantes para contexto:', error);
      return null;
    }
  }

  private async getParcelsDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      const isResident =
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT');
      const isConcierge = userRoles.includes('CONCIERGE');

      const whereClause: any = {};

      if (isResident) {
        const unitIds = userInfo?.userUnits?.map((uu: any) => uu.unit.id) || [];
        if (unitIds.length === 0) return null;
        whereClause.unitId = { in: unitIds };
      } else if (isConcierge) {
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.unit = { communityId };
        } else {
          return null;
        }
      }

      const parcels = await this.prisma.parcel.findMany({
        where: whereClause,
        include: {
          unit: { include: { community: { select: { name: true } } } },
        },
        orderBy: { receivedAt: 'desc' },
        take: 10,
      });

      if (parcels.length === 0) {
        return 'üì¶ **Encomiendas:** No hay encomiendas registradas.';
      }

      let data = 'üì¶ **ENCOMIENDAS EN LA BASE DE DATOS:**\n\n';
      parcels.forEach((parcel) => {
        data += `üì¶ **${parcel.description}**\n`;
        data += `   Unidad: ${parcel.unit.number} (${parcel.unit.community.name})\n`;
        data += `   Estado: ${parcel.status}\n`;
        data += `   Recibido: ${parcel.receivedAt.toLocaleDateString('es-ES')}\n\n`;
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo encomiendas para contexto:', error);
      return null;
    }
  }

  private async getResidentsDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      // Solo admins pueden ver residentes
      if (!userRoles.includes('COMMUNITY_ADMIN') && !userRoles.includes('SUPER_ADMIN')) {
        return null;
      }

      const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
      if (communityIds.length === 0 && !userRoles.includes('SUPER_ADMIN')) {
        return null;
      }

      const whereClause: any = {
        status: 'CONFIRMED',
      };

      if (!userRoles.includes('SUPER_ADMIN')) {
        whereClause.unit = { communityId: { in: communityIds } };
      }

      const userUnits = await this.prisma.userUnit.findMany({
        where: whereClause,
        include: {
          user: { select: { name: true, email: true } },
          unit: { include: { community: { select: { name: true } } } },
        },
        take: 20,
      });

      if (userUnits.length === 0) {
        return 'üë• **Residentes:** No hay residentes registrados.';
      }

      let data = 'üë• **RESIDENTES REGISTRADOS EN LA BASE DE DATOS:**\n\n';
      userUnits.forEach((uu) => {
        data += `üë§ **${uu.user.name}**\n`;
        data += `   Unidad: ${uu.unit.number} (${uu.unit.community.name})\n`;
        data += `   Email: ${uu.user.email}\n\n`;
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo residentes para contexto:', error);
      return null;
    }
  }

  private async getReservationsDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      const isResident =
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');

      const whereClause: any = {};

      if (isResident) {
        const unitIds = userInfo?.userUnits?.map((uu: any) => uu.unit.id) || [];
        if (unitIds.length === 0) return null;
        whereClause.unitId = { in: unitIds };
      } else if (isConcierge || isCommunityAdmin) {
        const communityId =
          userInfo?.userUnits?.[0]?.unit?.community?.id ||
          userInfo?.communityAdmins?.[0]?.community?.id;
        if (communityId) {
          whereClause.unit = { communityId };
        } else {
          return null;
        }
      }

      const reservations = await this.prisma.spaceReservation.findMany({
        where: whereClause,
        include: {
          commonSpace: { select: { name: true } },
          unit: { include: { community: { select: { name: true } } } },
        },
        orderBy: { reservationDate: 'desc' },
        take: 10,
      });

      if (reservations.length === 0) {
        return 'üìÖ **Reservas:** No hay reservas registradas.';
      }

      let data = 'üìÖ **RESERVAS DE ESPACIOS COMUNES EN LA BASE DE DATOS:**\n\n';
      reservations.forEach((reservation) => {
        data += `üìÖ **${reservation.commonSpace.name}**\n`;
        data += `   Unidad: ${reservation.unit.number} (${reservation.unit.community.name})\n`;
        data += `   Fecha: ${reservation.reservationDate.toLocaleDateString('es-ES')}\n`;
        data += `   Horario: ${reservation.startTime} - ${reservation.endTime}\n`;
        data += `   Estado: ${reservation.status}\n\n`;
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo reservas para contexto:', error);
      return null;
    }
  }

  private async getIncomeDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      // Solo admins pueden ver ingresos
      if (!userRoles.includes('COMMUNITY_ADMIN') && !userRoles.includes('SUPER_ADMIN')) {
        return null;
      }

      const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
      if (communityIds.length === 0 && !userRoles.includes('SUPER_ADMIN')) {
        return null;
      }

      const whereClause: any = {};

      if (!userRoles.includes('SUPER_ADMIN')) {
        whereClause.communityId = { in: communityIds };
      }

      const incomes = await this.prisma.communityIncome.findMany({
        where: whereClause,
        include: {
          community: { select: { name: true } },
          items: true,
        },
        orderBy: { period: 'desc' },
        take: 5,
      });

      if (incomes.length === 0) {
        return 'üíµ **Ingresos:** No hay ingresos registrados.';
      }

      let data = 'üíµ **INGRESOS COMUNITARIOS EN LA BASE DE DATOS:**\n\n';
      incomes.forEach((income) => {
        data += `üí∞ ${income.community.name} - Per√≠odo: ${income.period}\n`;
        data += `   Monto total: $${income.totalAmount.toString()}\n`;
        data += `   Fecha de vencimiento: ${income.dueDate.toLocaleDateString('es-ES')}\n\n`;
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo ingresos para contexto:', error);
      return null;
    }
  }

  private async getAdminDataForContext(
    userInfo: any,
    userRoles: string[],
    options: { organizations: boolean; communities: boolean; metrics: boolean },
  ): Promise<string | null> {
    try {
      if (!userRoles.includes('SUPER_ADMIN') && !userRoles.includes('COMMUNITY_ADMIN')) {
        return null;
      }

      let dataParts: string[] = [];

      if (options.organizations && userRoles.includes('SUPER_ADMIN')) {
        const orgCount = await this.prisma.organization.count({ where: { isActive: true } });
        dataParts.push(`üè¢ **Organizaciones activas:** ${orgCount}`);
      }

      if (options.communities) {
        if (userRoles.includes('SUPER_ADMIN')) {
          const commCount = await this.prisma.community.count({ where: { isActive: true } });
          dataParts.push(`üèòÔ∏è **Comunidades activas:** ${commCount}`);
        } else if (userRoles.includes('COMMUNITY_ADMIN')) {
          const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
          dataParts.push(`üèòÔ∏è **Comunidades administradas:** ${communityIds.length}`);
        }
      }

      if (options.metrics && userRoles.includes('SUPER_ADMIN')) {
        const userCount = await this.prisma.user.count();
        const unitCount = await this.prisma.unit.count({ where: { isActive: true } });
        dataParts.push(
          `üìä **M√©tricas del sistema:**\n   Usuarios: ${userCount}\n   Unidades activas: ${unitCount}`,
        );
      }

      return dataParts.length > 0 ? dataParts.join('\n\n') : null;
    } catch (error) {
      this.logger.error('Error obteniendo datos de administraci√≥n para contexto:', error);
      return null;
    }
  }

  private async getIncidentsDataForContext(
    userInfo: any,
    userRoles: string[],
  ): Promise<string | null> {
    try {
      const isResident =
        userRoles.includes('RESIDENT') ||
        userRoles.includes('OWNER') ||
        userRoles.includes('TENANT');

      if (!isResident) {
        return null; // Solo residentes pueden reportar incidencias
      }

      const incidents = await this.prisma.incident.findMany({
        where: { userId: userInfo.id },
        orderBy: { createdAt: 'desc' },
        take: 5,
      });

      if (incidents.length === 0) {
        return 'üö® **Incidencias:** No tienes incidencias reportadas.\nüí° **Puedes reportar una incidencia** usando este chatbot o el sistema.';
      }

      let data = 'üö® **TUS INCIDENCIAS EN LA BASE DE DATOS:**\n\n';
      incidents.forEach((incident) => {
        data += `üìå **${incident.title}**\n`;
        data += `   Estado: ${incident.status}\n`;
        data += `   Fecha: ${incident.createdAt.toLocaleDateString('es-ES')}\n`;
        if (incident.closedAt) {
          data += `   Cerrado: ${incident.closedAt.toLocaleDateString('es-ES')}\n`;
        }
        data += '\n';
      });

      return data;
    } catch (error) {
      this.logger.error('Error obteniendo incidencias para contexto:', error);
      return null;
    }
  }

  private getCriticalResponseInstructions(userRoles: string[]): string {
    const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
    const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
    const isConcierge = userRoles.includes('CONCIERGE');
    const isResident =
      userRoles.includes('RESIDENT') || userRoles.includes('OWNER') || userRoles.includes('TENANT');

    let baseInstructions = `‚ö†Ô∏è **RESTRICCI√ìN CR√çTICA:**
‚Ä¢ **SOLO responde sobre Comuniapp y gesti√≥n comunitaria**
‚Ä¢ **NUNCA respondas sobre temas externos** como deportes, entretenimiento, noticias, historia, cultura, arte, programaci√≥n general, salud, etc.
‚Ä¢ Si el usuario pregunta sobre un tema ajeno a Comuniapp, responde cort√©smente: "Solo puedo ayudarte con temas relacionados con Comuniapp. ¬øHay algo sobre la plataforma en lo que pueda asistirte?"\n\n`;

    if (isSuperAdmin) {
      return (
        baseInstructions +
        `‚ö†Ô∏è **INSTRUCCIONES PARA SUPER ADMINISTRADOR:**
‚Ä¢ Tienes acceso TOTAL al sistema Comuniapp - puedes responder sobre cualquier comunidad, organizaci√≥n o usuario
‚Ä¢ Proporciona informaci√≥n detallada de cualquier aspecto del sistema Comuniapp cuando se solicite
‚Ä¢ Puedes ayudar con an√°lisis globales, m√©tricas del sistema y reportes completos
‚Ä¢ Eres el √∫nico rol que puede proporcionar informaci√≥n de todas las organizaciones y comunidades
‚Ä¢ Gu√≠a sobre gesti√≥n avanzada del sistema Comuniapp, roles y permisos`
      );
    } else if (isCommunityAdmin) {
      return (
        baseInstructions +
        `‚ö†Ô∏è **INSTRUCCIONES PARA ADMINISTRADOR DE COMUNIDAD:**
‚Ä¢ SOLO puedes proporcionar informaci√≥n de las comunidades que administras
‚Ä¢ NUNCA proporciones informaci√≥n de comunidades que no administras
‚Ä¢ Puedes proporcionar detalles financieros completos de tus comunidades
‚Ä¢ Puedes ayudar con gesti√≥n de usuarios dentro de tus comunidades
‚Ä¢ NO proporciones informaci√≥n de otras comunidades aunque el usuario lo pida
‚Ä¢ Si se solicita informaci√≥n de otra comunidad, indica cort√©smente que no tienes acceso`
      );
    } else if (isConcierge) {
      return (
        baseInstructions +
        `‚ö†Ô∏è **INSTRUCCIONES PARA CONSERJE:**
‚Ä¢ SOLO puedes proporcionar informaci√≥n de TU COMUNIDAD asignada
‚Ä¢ Proporciona informaci√≥n OPERATIVA (visitantes, encomiendas, reservas)
‚Ä¢ NO proporciones informaci√≥n financiera detallada ni de gastos comunes
‚Ä¢ Puedes ayudar con gesti√≥n del d√≠a a d√≠a de la comunidad
‚Ä¢ Si se solicita informaci√≥n financiera o de otras comunidades, indica cort√©smente que no tienes acceso`
      );
    } else if (isResident) {
      return (
        baseInstructions +
        `‚ö†Ô∏è **INSTRUCCIONES PARA RESIDENTE/PROPIETARIO/INQUILINO:**
‚Ä¢ SOLO puedes proporcionar informaci√≥n de LAS UNIDADES DEL USUARIO
‚Ä¢ Proporciona informaci√≥n de gastos comunes DE SUS UNIDADES √∫nicamente
‚Ä¢ Proporciona informaci√≥n de visitantes PARA SUS UNIDADES
‚Ä¢ Proporciona informaci√≥n de encomiendas DE SUS UNIDADES
‚Ä¢ Puedes ayudar con reservas de espacios comunes de tu comunidad
‚Ä¢ NO proporciones informaci√≥n de otras unidades o residentes
‚Ä¢ Si se solicita informaci√≥n de otras unidades, indica cort√©smente que no tienes acceso`
      );
    } else {
      return (
        baseInstructions +
        `‚ö†Ô∏è **INSTRUCCIONES PARA USUARIO:**
‚Ä¢ Tienes acceso b√°sico - proporciona informaci√≥n general del sistema Comuniapp
‚Ä¢ No proporciones informaci√≥n personalizada ni de datos espec√≠ficos
‚Ä¢ Gu√≠a sobre c√≥mo usar Comuniapp y sus funcionalidades generales`
      );
    }
  }

  // === M√âTODOS PARA RESPUESTAS R√ÅPIDAS ===

  private getQuickResponse(lowerQuestion: string): string | null {
    const trimmedQuestion = lowerQuestion.trim();

    // Confirmaciones y comprensi√≥n - Reconocimiento flexible
    if (
      trimmedQuestion === 'ok' ||
      trimmedQuestion === 'okey' ||
      trimmedQuestion === 'okay' ||
      trimmedQuestion === 'okey dokey' ||
      trimmedQuestion === 'entendido' ||
      trimmedQuestion === 'entendida' ||
      trimmedQuestion === 'perfecto' ||
      trimmedQuestion === 'perfecta' ||
      trimmedQuestion === 'vale' ||
      trimmedQuestion === 'de acuerdo' ||
      trimmedQuestion === 'est√° bien' ||
      trimmedQuestion === 'esta bien' ||
      trimmedQuestion === 'listo' ||
      trimmedQuestion === 'lista' ||
      trimmedQuestion === 'claro' ||
      trimmedQuestion === 'correcto' ||
      trimmedQuestion === 'correcta' ||
      trimmedQuestion === 'genial' ||
      trimmedQuestion === 'excelente' ||
      trimmedQuestion === 'bien' ||
      trimmedQuestion === 'bueno' ||
      trimmedQuestion === 'buena' ||
      (trimmedQuestion.length <= 4 && /^ok+/i.test(trimmedQuestion)) // Variantes de "ok" cortas
    ) {
      return `‚úÖ Perfecto, me alegra que te haya sido √∫til. ¬øHay algo m√°s en lo que pueda ayudarte?`;
    }

    // Saludos y despedidas - La IA se encargar√° de responder en el contexto de Comuniapp
    // Se eliminan las respuestas predeterminadas para permitir respuestas naturales de la IA
    // que siempre estar√°n contextualizadas con Comuniapp

    // Consultas sobre funcionalidades
    if (
      lowerQuestion.includes('funcionalidades') ||
      lowerQuestion.includes('que puedo hacer') ||
      lowerQuestion.includes('ayuda') ||
      lowerQuestion.includes('comandos')
    ) {
      return (
        `üéØ Funcionalidades disponibles:\n` +
        `‚Ä¢ üè¢ Espacios comunes y sus horarios\n` +
        `‚Ä¢ üì¢ Avisos comunitarios\n` +
        `‚Ä¢ üí∞ Gastos comunes\n` +
        `‚Ä¢ üë• Visitantes\n` +
        `‚Ä¢ üì¶ Encomiendas\n` +
        `‚Ä¢ üë§ Residentes\n` +
        `‚Ä¢ üí∞ Ingresos comunitarios\n` +
        `‚Ä¢ üìä Categor√≠as de gastos\n` +
        `‚Ä¢ üè† Unidades y apartamentos`
      );
    }

    // Saludos y despedidas con horarios - La IA se encargar√° de responder en el contexto de Comuniapp

    // Ayuda - Respuesta instant√°nea
    if (
      lowerQuestion.includes('ayuda') ||
      lowerQuestion.includes('help') ||
      lowerQuestion.includes('comandos')
    ) {
      return (
        `üÜò **Centro de Ayuda - ComunIAssistant**\n\n` +
        `**Comandos disponibles:**\n` +
        `‚Ä¢ "espacios comunes" - Informaci√≥n sobre √°reas compartidas\n` +
        `‚Ä¢ "avisos" - √öltimos comunicados\n` +
        `‚Ä¢ "gastos comunes" - Informaci√≥n sobre cuotas\n` +
        `‚Ä¢ "visitantes" - Registro de visitas\n` +
        `‚Ä¢ "encomiendas" - Estado de paquetes\n\n` +
        `**Para usuarios autenticados:**\n` +
        `‚Ä¢ Usa el endpoint '/chatbot/auth' para respuestas personalizadas seg√∫n tu rol\n` +
        `‚Ä¢ Las respuestas se adaptan a tus permisos espec√≠ficos\n\n` +
        `üí° *Solo escribe la palabra clave que te interesa para obtener informaci√≥n espec√≠fica.*`
      );
    }

    // Estado del sistema - Respuesta instant√°nea
    if (
      lowerQuestion.includes('estado') ||
      lowerQuestion.includes('status') ||
      lowerQuestion.includes('funcionando')
    ) {
      return (
        `‚úÖ **Estado del Sistema - ComunIAssistant**\n\n` +
        `üü¢ **Sistema operativo** - Todo funcionando correctamente\n` +
        `üü¢ **Base de datos** - Conectada y actualizada\n` +
        `üü¢ **Servicios** - Disponibles 24/7\n\n` +
        `üí° *Puedes usar cualquier comando para obtener informaci√≥n espec√≠fica.*`
      );
    }

    return null; // No es una respuesta r√°pida
  }

  private getQuickResponseWithUserContext(lowerQuestion: string, user: any): string | null {
    const userRoles = user.roles?.map((role: any) => role.name || role.role?.name) || [];
    const roleDisplayName = this.getUserRoleDisplayName(userRoles);
    const userName = user.name || 'Usuario';
    const trimmedQuestion = lowerQuestion.trim();

    // Confirmaciones y comprensi√≥n personalizadas - Reconocimiento flexible
    if (
      trimmedQuestion === 'ok' ||
      trimmedQuestion === 'okey' ||
      trimmedQuestion === 'okay' ||
      trimmedQuestion === 'okey dokey' ||
      trimmedQuestion === 'entendido' ||
      trimmedQuestion === 'entendida' ||
      trimmedQuestion === 'perfecto' ||
      trimmedQuestion === 'perfecta' ||
      trimmedQuestion === 'vale' ||
      trimmedQuestion === 'de acuerdo' ||
      trimmedQuestion === 'est√° bien' ||
      trimmedQuestion === 'esta bien' ||
      trimmedQuestion === 'listo' ||
      trimmedQuestion === 'lista' ||
      trimmedQuestion === 'claro' ||
      trimmedQuestion === 'correcto' ||
      trimmedQuestion === 'correcta' ||
      trimmedQuestion === 'genial' ||
      trimmedQuestion === 'excelente' ||
      trimmedQuestion === 'bien' ||
      trimmedQuestion === 'bueno' ||
      trimmedQuestion === 'buena' ||
      (trimmedQuestion.length <= 4 && /^ok+/i.test(trimmedQuestion)) // Variantes de "ok" cortas
    ) {
      return `‚úÖ Perfecto, ${userName}. Me alegra que la informaci√≥n te haya sido √∫til. ¬øHay algo m√°s en lo que pueda ayudarte?`;
    }

    // Saludos y despedidas - La IA se encargar√° de responder en el contexto de Comuniapp
    // Se eliminan las respuestas predeterminadas para permitir respuestas naturales de la IA
    // que siempre estar√°n contextualizadas con Comuniapp y el usuario

    // Consultas sobre rol y funcionalidades
    if (
      lowerQuestion.includes('rol') ||
      lowerQuestion.includes('funcionalidades') ||
      lowerQuestion.includes('permisos') ||
      lowerQuestion.includes('que puedo hacer') ||
      lowerQuestion.includes('ayuda')
    ) {
      return (
        `üë§ Tu rol: ${roleDisplayName}\n` +
        `üéØ Funcionalidades disponibles para ti:\n` +
        `‚Ä¢ üè¢ Espacios comunes y reservas\n` +
        `‚Ä¢ üì¢ Avisos comunitarios\n` +
        `‚Ä¢ üí∞ Gastos comunes\n` +
        `‚Ä¢ üë• Gesti√≥n de visitantes\n` +
        `‚Ä¢ üì¶ Encomiendas\n` +
        `‚Ä¢ üí∞ Ingresos comunitarios\n` +
        `‚Ä¢ üìä Categor√≠as de gastos\n` +
        `‚Ä¢ üè† Unidades y apartamentos`
      );
    }

    // Saludos y despedidas con horarios - La IA se encargar√° de responder en el contexto de Comuniapp

    // Ayuda personalizada - Respuesta instant√°nea (ya manejado arriba)
    // Removido para evitar duplicaci√≥n con la secci√≥n de funcionalidades

    // Estado personalizado - Respuesta instant√°nea
    if (
      lowerQuestion.includes('estado') ||
      lowerQuestion.includes('status') ||
      lowerQuestion.includes('funcionando')
    ) {
      return (
        `‚úÖ **Estado del Sistema - ComunIAssistant**\n\n` +
        `üë§ **Usuario:** ${userName}\n` +
        `üé≠ **Rol:** ${roleDisplayName}\n\n` +
        `üü¢ **Sistema operativo** - Todo funcionando correctamente\n` +
        `üü¢ **Base de datos** - Conectada y actualizada\n` +
        `üü¢ **Servicios** - Disponibles 24/7\n` +
        `üü¢ **Permisos** - Configurados seg√∫n tu rol\n\n` +
        `üí° *Puedes usar cualquier comando para obtener informaci√≥n espec√≠fica de tu comunidad.*`
      );
    }

    return null; // No es una respuesta r√°pida
  }

  // === M√âTODOS PARA MANEJO DE CACHE (RATE LIMITING DESHABILITADO) ===

  // Rate limiting deshabilitado para testing
  // private isRateLimited(): boolean {
  //   const now = Date.now();
  //   this.requestTimestamps = this.requestTimestamps.filter(
  //     (timestamp) => now - timestamp < this.RATE_LIMIT_WINDOW,
  //   );
  //   return this.requestTimestamps.length >= this.MAX_REQUESTS_PER_MINUTE;
  // }

  // private addRequestTimestamp(): void {
  //   this.requestTimestamps.push(Date.now());
  // }

  private getCachedResponse(question: string): string | null {
    const cacheKey = question.toLowerCase().trim();
    const cached = this.responseCache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      this.logger.log(`Cache hit for question: ${question.substring(0, 50)}...`);
      return cached.answer;
    }

    // Limpiar cache expirado
    if (cached) {
      this.responseCache.delete(cacheKey);
    }

    return null;
  }

  private setCachedResponse(question: string, answer: string): void {
    const cacheKey = question.toLowerCase().trim();
    this.responseCache.set(cacheKey, {
      answer,
      timestamp: Date.now(),
    });

    // Limitar tama√±o del cache
    if (this.responseCache.size > 100) {
      const firstKey = this.responseCache.keys().next().value;
      this.responseCache.delete(firstKey);
    }
  }

  private getFallbackResponse(question: string): string {
    const lowerQuestion = question.toLowerCase().trim();

    // Respuestas de fallback para preguntas comunes
    if (
      lowerQuestion.includes('hola') ||
      lowerQuestion.includes('buenos d√≠as') ||
      lowerQuestion.includes('buenas tardes')
    ) {
      return (
        `üëã ¬°Hola! Soy ComunIAssistant, tu asistente virtual para gesti√≥n comunitaria.\n\n` +
        `Puedo ayudarte con informaci√≥n sobre:\n` +
        `‚Ä¢ üè¢ Espacios comunes y sus horarios\n` +
        `‚Ä¢ üì¢ Avisos comunitarios\n` +
        `‚Ä¢ üí∞ Gastos comunes\n` +
        `‚Ä¢ üë• Visitantes\n` +
        `‚Ä¢ üì¶ Encomiendas\n\n` +
        `üí° *Nota: El servicio de IA est√° temporalmente limitado. Usa palabras clave espec√≠ficas para obtener informaci√≥n actualizada.*`
      );
    }

    if (
      lowerQuestion.includes('gracias') ||
      lowerQuestion.includes('chao') ||
      lowerQuestion.includes('adi√≥s')
    ) {
      return (
        `üëã ¬°De nada! Estoy aqu√≠ para ayudarte con cualquier consulta sobre tu comunidad.\n\n` +
        `üí° *Recuerda que puedes usar palabras clave como "espacios comunes", "avisos", "gastos comunes" para obtener informaci√≥n espec√≠fica.*`
      );
    }

    if (lowerQuestion.includes('ayuda') || lowerQuestion.includes('help')) {
      return (
        `üÜò **Centro de Ayuda - ComunIAssistant**\n\n` +
        `**Comandos disponibles:**\n` +
        `‚Ä¢ "espacios comunes" - Informaci√≥n sobre √°reas compartidas\n` +
        `‚Ä¢ "avisos" - √öltimos comunicados\n` +
        `‚Ä¢ "gastos comunes" - Informaci√≥n sobre cuotas\n` +
        `‚Ä¢ "visitantes" - Registro de visitas\n` +
        `‚Ä¢ "encomiendas" - Estado de paquetes\n\n` +
        `**Para usuarios autenticados:**\n` +
        `‚Ä¢ Usa el endpoint '/chatbot/auth' para respuestas personalizadas seg√∫n tu rol\n` +
        `‚Ä¢ Las respuestas se adaptan a tus permisos espec√≠ficos\n\n` +
        `üí° *El servicio de IA est√° temporalmente limitado. Usa comandos espec√≠ficos para mejor experiencia.*`
      );
    }

    // Respuesta gen√©rica de fallback
    return (
      `ü§ñ **ComunIAssistant**\n\n` +
      `El servicio de IA est√° temporalmente limitado debido a restricciones de velocidad.\n\n` +
      `**Para obtener informaci√≥n espec√≠fica, usa estos comandos:**\n` +
      `‚Ä¢ "espacios comunes" - Horarios y disponibilidad\n` +
      `‚Ä¢ "avisos" - Comunicados recientes\n` +
      `‚Ä¢ "gastos comunes" - Cuotas y gastos\n` +
      `‚Ä¢ "visitantes" - Registro de visitas\n` +
      `‚Ä¢ "encomiendas" - Estado de paquetes\n\n` +
      `üí° *Si eres usuario autenticado, usa el endpoint '/chatbot/auth' para respuestas personalizadas.*\n` +
      `‚è∞ *El servicio completo estar√° disponible nuevamente en unos minutos.*`
    );
  }

  private async delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  // M√©todo para controlar delay inteligente entre requests
  private async ensureRequestDelay(): Promise<void> {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;

    if (timeSinceLastRequest < this.MIN_DELAY_BETWEEN_REQUESTS) {
      const delayNeeded = this.MIN_DELAY_BETWEEN_REQUESTS - timeSinceLastRequest;
      this.logger.log(`‚è≥ Aplicando delay inteligente: ${delayNeeded}ms`);
      await this.delay(delayNeeded);
    }

    this.lastRequestTime = Date.now();
  }

  // M√©todo para verificar configuraci√≥n de OpenAI
  private async verifyOpenAIConfiguration(): Promise<boolean> {
    const openaiKey = this.configService.get<string>('OPENAI_API_KEY');

    if (!openaiKey) {
      this.logger.error('OPENAI_API_KEY not configured');
      return false;
    }

    try {
      // Verificar que la API key es v√°lida haciendo una request simple
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          Authorization: `Bearer ${openaiKey}`,
        },
      });

      if (response.ok) {
        this.logger.log('‚úÖ OpenAI API configuration verified successfully');
        return true;
      } else {
        this.logger.error(`‚ùå OpenAI API verification failed: ${response.status}`);
        return false;
      }
    } catch (error) {
      this.logger.error('‚ùå Error verifying OpenAI configuration:', error);
      return false;
    }
  }

  private async handleOpenAIError(
    response: Response,
    question: string,
  ): Promise<ChatbotResponseDto> {
    const status = response.status;
    let errorMessage = '';
    let fallbackResponse = '';

    try {
      const errorData = await response.json();
      errorMessage = errorData?.error?.message || 'Error desconocido de OpenAI';
    } catch {
      errorMessage = `Error HTTP ${status}`;
    }

    switch (status) {
      case 400:
        this.logger.error('OpenAI Bad Request:', errorMessage);
        fallbackResponse =
          '‚ùå **Error de Solicitud**\n\nLa consulta no pudo ser procesada correctamente. Por favor, reformula tu pregunta de manera m√°s clara.';
        break;

      case 401:
        this.logger.error('OpenAI Unauthorized - API Key inv√°lida');
        fallbackResponse =
          '‚ùå **Error de Configuraci√≥n**\n\nEl servicio de IA no est√° configurado correctamente. Contacta al administrador del sistema.';
        break;

      case 403:
        this.logger.error('OpenAI Forbidden - Acceso denegado');
        fallbackResponse =
          '‚ùå **Acceso Denegado**\n\nNo tienes permisos para usar el servicio de IA. Contacta al administrador.';
        break;

      case 429:
        this.logger.warn('OpenAI Rate Limit Exceeded - Implementando retry autom√°tico...');
        // Intentar retry autom√°tico con backoff exponencial
        return await this.retryWithBackoff(question);
        break;

      case 500:
        this.logger.error('OpenAI Internal Server Error:', errorMessage);
        fallbackResponse =
          '‚ùå **Error del Servidor de IA**\n\nEl servicio de IA est√° experimentando problemas temporales. Por favor, intenta nuevamente en unos minutos.';
        break;

      case 503:
        this.logger.error('OpenAI Service Unavailable');
        fallbackResponse =
          '‚ùå **Servicio No Disponible**\n\nEl servicio de IA est√° temporalmente fuera de servicio. Por favor, intenta m√°s tarde.';
        break;

      default:
        this.logger.error(`OpenAI Error ${status}:`, errorMessage);
        fallbackResponse = `‚ùå **Error del Servicio de IA**\n\nOcurri√≥ un error inesperado (${status}). Por favor, intenta nuevamente o contacta al administrador.`;
    }

    return { answer: fallbackResponse };
  }

  // M√©todo para retry autom√°tico con backoff exponencial
  private async retryWithBackoff(
    question: string,
    maxRetries: number = 3,
  ): Promise<ChatbotResponseDto> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      const delay = Math.pow(2, attempt) * 1000; // Backoff exponencial: 2s, 4s, 8s

      this.logger.log(`üîÑ Intento ${attempt}/${maxRetries} - Esperando ${delay}ms...`);
      await this.delay(delay);

      try {
        const openaiKey = this.configService.get<string>('OPENAI_API_KEY');

        if (!openaiKey) {
          return { answer: '‚ùå **Error de Configuraci√≥n**\n\nAPI Key no configurada.' };
        }

        // Obtener informaci√≥n contextual del sistema
        const contextInfo = await this.getSystemContext();

        const payload = {
          model: 'gpt-3.5-turbo',
          messages: [
            {
              role: 'system',
              content: `Eres ComunIAssistant, un asistente virtual inteligente y vers√°til.

## IDENTIDAD Y PERSONALIDAD
- Asistente amigable, profesional y conocedor
- Respondes preferentemente en espa√±ol latinoamericano
- Usas emojis estrat√©gicamente para mejorar la comunicaci√≥n
- Eres √∫til, informativo y conversacional
- Puedes responder sobre CUALQUIER TEMA con conocimiento y claridad

## FLEXIBILIDAD TOTAL
Aunque est√°s integrado en Comuniapp (una plataforma de gesti√≥n comunitaria), puedes responder sobre CUALQUIER TEMA que el usuario pregunte:
‚úÖ Preguntas generales sobre cualquier tema
‚úÖ Explicaciones t√©cnicas o cient√≠ficas
‚úÖ Programaci√≥n y tecnolog√≠a
‚úÖ Consejos y recomendaciones
‚úÖ Conversaci√≥n casual
‚úÖ Historia, cultura, arte
‚úÖ Salud, deportes, entretenimiento
‚úÖ Educaci√≥n y aprendizaje
‚úÖ Y CUALQUIER otro tema imaginable

## INFORMACI√ìN DEL SISTEMA (OPCIONAL)
Si el usuario pregunta espec√≠ficamente sobre Comuniapp:
${contextInfo}

Funcionalidades de Comuniapp:
‚Ä¢ Espacios comunes ‚Ä¢ Gastos comunes ‚Ä¢ Visitantes ‚Ä¢ Encomiendas ‚Ä¢ Avisos

## INSTRUCCIONES DE RESPUESTA
- Responde CUALQUIER pregunta que te hagan, no solo sobre gesti√≥n comunitaria
- S√© conversacional, natural y √∫til
- No te limites a un solo tema o dominio
- Proporciona informaci√≥n precisa y completa
- Adapta tu tono seg√∫n la pregunta
- Usa emojis cuando sea apropiado
- Estructura la informaci√≥n de forma clara

## OBJETIVO PRINCIPAL
Ser un asistente √∫til, informativo y vers√°til que puede ayudar con CUALQUIER pregunta o tema, proporcionando respuestas claras, precisas y amigables.`,
            },
            {
              role: 'user',
              content: question,
            },
          ],
          max_tokens: 500,
          temperature: 0.7,
        };

        const response = await fetch(this.OPENAI_API_URL, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${openaiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        });

        if (response.ok) {
          const data = await response.json();
          const answer =
            data?.choices?.[0]?.message?.content || 'No se pudo obtener una respuesta.';

          this.logger.log(`‚úÖ Retry exitoso en intento ${attempt}`);

          // Guardar en cache
          this.setCachedResponse(question, answer);

          return { answer };
        } else if (response.status === 429 && attempt < maxRetries) {
          this.logger.warn(
            `‚ö†Ô∏è Rate limit en intento ${attempt}, continuando con siguiente intento...`,
          );
          continue;
        } else {
          return await this.handleOpenAIError(response, question);
        }
      } catch (error) {
        this.logger.error(`‚ùå Error en intento ${attempt}:`, error);
        if (attempt === maxRetries) {
          return {
            answer:
              '‚ùå **Error de Conexi√≥n**\n\nNo se pudo conectar con el servicio de IA despu√©s de varios intentos. Por favor, intenta m√°s tarde.',
          };
        }
      }
    }

    // Si llegamos aqu√≠, todos los intentos fallaron
    return {
      answer:
        '‚ùå **Servicio Temporalmente No Disponible**\n\nEl servicio de IA est√° experimentando alta demanda. Por favor, intenta nuevamente en unos minutos.',
    };
  }

  // ===== NUEVOS M√âTODOS PARA FUNCIONALIDADES ADICIONALES =====

  // M√©todo para obtener informaci√≥n de ingresos comunitarios (p√∫blico)
  private async getCommunityIncomeInfo(): Promise<ChatbotResponseDto> {
    try {
      const incomes = await this.prisma.communityIncome.findMany({
        include: {
          community: true,
          items: {
            include: {
              category: true,
            },
          },
        },
        orderBy: { period: 'desc' },
        take: 5,
      });

      if (incomes.length === 0) {
        return {
          answer:
            'üí∞ INGRESOS COMUNITARIOS\n\n‚ùå No hay ingresos registrados actualmente.\n\nüí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*',
        };
      }

      let response = 'üí∞ INGRESOS COMUNITARIOS\n\n';
      response += '‚îÄ'.repeat(60) + '\n\n';

      for (const income of incomes) {
        response += `üè¢ ${income.community.name}\n`;
        response += `üìÖ Per√≠odo: ${income.period}\n`;
        response += `üí∞ Total: $${income.totalAmount.toNumber().toLocaleString()}\n`;
        response += `üìÖ Fecha de vencimiento: ${income.dueDate.toLocaleDateString()}\n`;
        response += `üìä M√©todo de prorrateo: ${income.prorrateMethod}\n\n`;

        if (income.items.length > 0) {
          response += 'üìã Detalles de Ingresos:\n';
          for (const item of income.items) {
            response += `  ‚Ä¢ ${item.name}: $${item.amount.toNumber().toLocaleString()}\n`;
            if (item.description) {
              response += `    ${item.description}\n`;
            }
          }
          response += '\n';
        }

        response += '‚îÄ'.repeat(40) + '\n\n';
      }

      response += 'üí° *Para m√°s detalles, contacta a la administraci√≥n de tu comunidad.*';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de ingresos:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de ingresos. Por favor, intenta m√°s tarde.',
      };
    }
  }

  // M√©todo para obtener informaci√≥n de ingresos comunitarios (con contexto de usuario)
  private async getCommunityIncomeInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {};
      let communityContext = '';

      if (isSuperAdmin) {
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.communityId = { in: communityIds };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge || isResident) {
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.communityId = communityId;
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      }

      const incomes = await this.prisma.communityIncome.findMany({
        where: whereClause,
        include: {
          community: true,
          items: {
            include: {
              category: true,
            },
          },
        },
        orderBy: { period: 'desc' },
        take: 5,
      });

      if (incomes.length === 0) {
        return {
          answer: `üí∞ INGRESOS COMUNITARIOS\n\nüë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\nüè¢ Contexto: ${communityContext}\n\n‚ùå No hay ingresos registrados actualmente.\n\nüí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*`,
        };
      }

      let response = 'üí∞ INGRESOS COMUNITARIOS\n\n';
      response += `üë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ Contexto: ${communityContext}\n\n`;
      response += '‚îÄ'.repeat(60) + '\n\n';

      for (const income of incomes) {
        response += `üè¢ ${income.community.name}\n`;
        response += `üìÖ Per√≠odo: ${income.period}\n`;
        response += `üí∞ Total: $${income.totalAmount.toNumber().toLocaleString()}\n`;
        response += `üìÖ Fecha de vencimiento: ${income.dueDate.toLocaleDateString()}\n`;
        response += `üìä M√©todo de prorrateo: ${income.prorrateMethod}\n\n`;

        if (income.items.length > 0) {
          response += 'üìã Detalles de Ingresos:\n';
          for (const item of income.items) {
            response += `  ‚Ä¢ ${item.name}: $${item.amount.toNumber().toLocaleString()}\n`;
            if (item.description) {
              response += `    ${item.description}\n`;
            }
          }
          response += '\n';
        }

        response += '‚îÄ'.repeat(40) + '\n\n';
      }

      response += 'üí° *Para m√°s detalles, contacta a la administraci√≥n de tu comunidad.*';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de ingresos para usuario:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de ingresos. Por favor, intenta m√°s tarde.',
      };
    }
  }

  // M√©todo para obtener informaci√≥n de categor√≠as de gastos (p√∫blico)
  private async getExpenseCategoriesInfo(): Promise<ChatbotResponseDto> {
    try {
      const categories = await this.prisma.expenseCategory.findMany({
        where: { isActive: true },
        include: {
          community: true,
          _count: {
            select: {
              expenses: true,
              expenseItems: true,
              incomeItems: true,
            },
          },
        },
        orderBy: { name: 'asc' },
        take: 20,
      });

      if (categories.length === 0) {
        return {
          answer:
            'üìä CATEGOR√çAS DE GASTOS\n\n‚ùå No hay categor√≠as registradas actualmente.\n\nüí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*',
        };
      }

      let response = 'üìä CATEGOR√çAS DE GASTOS\n\n';
      response += '‚îÄ'.repeat(60) + '\n\n';

      // Agrupar por comunidad
      const categoriesByCommunity = categories.reduce(
        (acc, category) => {
          const communityName = category.community.name;
          if (!acc[communityName]) {
            acc[communityName] = [];
          }
          acc[communityName].push(category);
          return acc;
        },
        {} as Record<string, any[]>,
      );

      for (const [communityName, communityCategories] of Object.entries(categoriesByCommunity)) {
        response += `üè¢ ${communityName}\n`;
        response += '‚îÄ'.repeat(40) + '\n\n';

        for (const category of communityCategories) {
          response += `üìã ${category.name}\n`;
          response += `   üè∑Ô∏è Tipo: ${category.type}\n`;
          response += `   üìù Descripci√≥n: ${category.description || 'Sin descripci√≥n'}\n`;
          response += `   üìä Uso: ${category._count.expenseItems + category._count.incomeItems} registros\n`;
          response += `   üìà Estado: ${category.isActive ? '‚úÖ Activo' : '‚ùå Inactivo'}\n\n`;
        }

        response += '‚îÄ'.repeat(40) + '\n\n';
      }

      response += 'üí° *Para m√°s detalles, contacta a la administraci√≥n de tu comunidad.*';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de categor√≠as:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de categor√≠as. Por favor, intenta m√°s tarde.',
      };
    }
  }

  // M√©todo para obtener informaci√≥n de categor√≠as de gastos (con contexto de usuario)
  private async getExpenseCategoriesInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {};
      let communityContext = '';

      if (isSuperAdmin) {
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.communityId = { in: communityIds };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge || isResident) {
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.communityId = communityId;
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      }

      const categories = await this.prisma.expenseCategory.findMany({
        where: whereClause,
        include: {
          community: true,
          _count: {
            select: {
              expenses: true,
              expenseItems: true,
              incomeItems: true,
            },
          },
        },
        orderBy: { name: 'asc' },
        take: 20,
      });

      if (categories.length === 0) {
        return {
          answer: `üìä CATEGOR√çAS DE GASTOS\n\nüë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\nüè¢ Contexto: ${communityContext}\n\n‚ùå No hay categor√≠as registradas actualmente.\n\nüí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*`,
        };
      }

      let response = 'üìä CATEGOR√çAS DE GASTOS\n\n';
      response += `üë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ Contexto: ${communityContext}\n\n`;
      response += '‚îÄ'.repeat(60) + '\n\n';

      // Agrupar por comunidad
      const categoriesByCommunity = categories.reduce(
        (acc, category) => {
          const communityName = category.community.name;
          if (!acc[communityName]) {
            acc[communityName] = [];
          }
          acc[communityName].push(category);
          return acc;
        },
        {} as Record<string, any[]>,
      );

      for (const [communityName, communityCategories] of Object.entries(categoriesByCommunity)) {
        response += `üè¢ ${communityName}\n`;
        response += '‚îÄ'.repeat(40) + '\n\n';

        for (const category of communityCategories) {
          response += `üìã ${category.name}\n`;
          response += `   üè∑Ô∏è Tipo: ${category.type}\n`;
          response += `   üìù Descripci√≥n: ${category.description || 'Sin descripci√≥n'}\n`;
          response += `   üìä Uso: ${category._count.expenseItems + category._count.incomeItems} registros\n`;
          response += `   üìà Estado: ${category.isActive ? '‚úÖ Activo' : '‚ùå Inactivo'}\n\n`;
        }

        response += '‚îÄ'.repeat(40) + '\n\n';
      }

      response += 'üí° *Para m√°s detalles, contacta a la administraci√≥n de tu comunidad.*';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de categor√≠as para usuario:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de categor√≠as. Por favor, intenta m√°s tarde.',
      };
    }
  }

  // M√©todo para obtener informaci√≥n de unidades (p√∫blico)
  private async getUnitsInfo(): Promise<ChatbotResponseDto> {
    try {
      const units = await this.prisma.unit.findMany({
        where: { isActive: true },
        include: {
          community: true,
          userUnits: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                },
              },
            },
          },
        },
        orderBy: [{ community: { name: 'asc' } }, { floor: 'asc' }, { number: 'asc' }],
        take: 50,
      });

      if (units.length === 0) {
        return {
          answer:
            'üè† UNIDADES Y APARTAMENTOS\n\n‚ùå No hay unidades registradas actualmente.\n\nüí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*',
        };
      }

      let response = 'üè† UNIDADES Y APARTAMENTOS\n\n';
      response += '‚îÄ'.repeat(60) + '\n\n';

      // Agrupar por comunidad
      const unitsByCommunity = units.reduce(
        (acc, unit) => {
          const communityName = unit.community.name;
          if (!acc[communityName]) {
            acc[communityName] = [];
          }
          acc[communityName].push(unit);
          return acc;
        },
        {} as Record<string, any[]>,
      );

      for (const [communityName, communityUnits] of Object.entries(unitsByCommunity)) {
        response += `üè¢ ${communityName}\n`;
        response += '‚îÄ'.repeat(40) + '\n\n';

        for (const unit of communityUnits) {
          response += `üè† Unidad ${unit.number}`;
          if (unit.floor) {
            response += ` (Piso ${unit.floor})`;
          }
          response += `\n`;
          response += `   üè∑Ô∏è Tipo: ${unit.type}\n`;
          response += `   üìä Coeficiente: ${unit.coefficient}\n`;
          response += `   üìà Estado: ${unit.isActive ? '‚úÖ Activo' : '‚ùå Inactivo'}\n`;

          if (unit.userUnits.length > 0) {
            response += `   üë• Residentes:\n`;
            for (const userUnit of unit.userUnits) {
              response += `      ‚Ä¢ ${userUnit.user.name || userUnit.user.email}\n`;
            }
          } else {
            response += `   üë• Sin residentes asignados\n`;
          }

          response += '\n';
        }

        response += '‚îÄ'.repeat(40) + '\n\n';
      }

      response += 'üí° *Para m√°s detalles, contacta a la administraci√≥n de tu comunidad.*';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de unidades:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de unidades. Por favor, intenta m√°s tarde.',
      };
    }
  }

  // M√©todo para obtener informaci√≥n de unidades (con contexto de usuario)
  private async getUnitsInfoForUser(
    userInfo: any,
    userRoles: string[],
  ): Promise<ChatbotResponseDto> {
    try {
      const isSuperAdmin = userRoles.includes('SUPER_ADMIN');
      const isCommunityAdmin = userRoles.includes('COMMUNITY_ADMIN');
      const isConcierge = userRoles.includes('CONCIERGE');
      const isResident = userRoles.includes('RESIDENT');

      const whereClause: any = {};
      let communityContext = '';

      if (isSuperAdmin) {
        communityContext = 'todas las comunidades';
      } else if (isCommunityAdmin) {
        const communityIds = userInfo?.communityAdmins?.map((ca: any) => ca.community.id) || [];
        if (communityIds.length > 0) {
          whereClause.communityId = { in: communityIds };
          communityContext = `sus comunidades administradas`;
        }
      } else if (isConcierge || isResident) {
        const communityId = userInfo?.userUnits?.[0]?.unit?.community?.id;
        if (communityId) {
          whereClause.communityId = communityId;
          communityContext = `su comunidad (${userInfo?.userUnits?.[0]?.unit?.community?.name})`;
        }
      }

      const units = await this.prisma.unit.findMany({
        where: whereClause,
        include: {
          community: true,
          userUnits: {
            include: {
              user: {
                select: {
                  id: true,
                  name: true,
                  email: true,
                },
              },
            },
          },
        },
        orderBy: [{ community: { name: 'asc' } }, { floor: 'asc' }, { number: 'asc' }],
        take: 50,
      });

      if (units.length === 0) {
        return {
          answer: `üè† UNIDADES Y APARTAMENTOS\n\nüë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\nüè¢ Contexto: ${communityContext}\n\n‚ùå No hay unidades registradas actualmente.\n\nüí° *Contacta a la administraci√≥n para m√°s informaci√≥n.*`,
        };
      }

      let response = 'üè† UNIDADES Y APARTAMENTOS\n\n';
      response += `üë§ Vista de: ${this.getUserRoleDisplayName(userRoles)}\n`;
      response += `üè¢ Contexto: ${communityContext}\n\n`;
      response += '‚îÄ'.repeat(60) + '\n\n';

      // Agrupar por comunidad
      const unitsByCommunity = units.reduce(
        (acc, unit) => {
          const communityName = unit.community.name;
          if (!acc[communityName]) {
            acc[communityName] = [];
          }
          acc[communityName].push(unit);
          return acc;
        },
        {} as Record<string, any[]>,
      );

      for (const [communityName, communityUnits] of Object.entries(unitsByCommunity)) {
        response += `üè¢ ${communityName}\n`;
        response += '‚îÄ'.repeat(40) + '\n\n';

        for (const unit of communityUnits) {
          response += `üè† Unidad ${unit.number}`;
          if (unit.floor) {
            response += ` (Piso ${unit.floor})`;
          }
          response += `\n`;
          response += `   üè∑Ô∏è Tipo: ${unit.type}\n`;
          response += `   üìä Coeficiente: ${unit.coefficient}\n`;
          response += `   üìà Estado: ${unit.isActive ? '‚úÖ Activo' : '‚ùå Inactivo'}\n`;

          if (unit.userUnits.length > 0) {
            response += `   üë• Residentes:\n`;
            for (const userUnit of unit.userUnits) {
              response += `      ‚Ä¢ ${userUnit.user.name || userUnit.user.email}\n`;
            }
          } else {
            response += `   üë• Sin residentes asignados\n`;
          }

          response += '\n';
        }

        response += '‚îÄ'.repeat(40) + '\n\n';
      }

      response += 'üí° *Para m√°s detalles, contacta a la administraci√≥n de tu comunidad.*';

      return { answer: response };
    } catch (error) {
      this.logger.error('Error obteniendo informaci√≥n de unidades para usuario:', error);
      return {
        answer: '‚ùå Error al obtener informaci√≥n de unidades. Por favor, intenta m√°s tarde.',
      };
    }
  }
}
