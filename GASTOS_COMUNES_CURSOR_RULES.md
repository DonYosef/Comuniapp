# Reglas de Cursor para el M√≥dulo de Gastos Comunes - Comuniapp

## üìã Resumen del M√≥dulo

El m√≥dulo de **Gastos Comunes** es un sistema completo de gesti√≥n financiera que permite a las comunidades administrar tanto **egresos** (gastos comunes) como **ingresos** (ingresos comunitarios) con prorrateo autom√°tico por unidades residenciales.

### üéØ Funcionalidades Principales

#### **Para Administradores:**

- ‚úÖ Gesti√≥n de gastos comunes mensuales con prorrateo autom√°tico
- ‚úÖ Gesti√≥n de ingresos comunitarios con prorrateo autom√°tico
- ‚úÖ Selecci√≥n de m√©todo de prorrateo (igualitario o por coeficiente)
- ‚úÖ Configuraci√≥n de categor√≠as independientes para egresos e ingresos
- ‚úÖ Formularios din√°micos para m√∫ltiples √≠tems
- ‚úÖ Previsualizaci√≥n del prorrateo antes de crear
- ‚úÖ Estad√≠sticas detalladas y balance financiero
- ‚úÖ Tabla unificada con selector de tipo (Egresos/Ingresos)

#### **Para Residentes:**

- ‚úÖ Consulta de gastos personales prorrateados
- ‚úÖ Filtros por estado (todos, pendientes, pagados, vencidos)
- ‚úÖ Estad√≠sticas personales de pagos
- ‚úÖ Informaci√≥n detallada de cada gasto

---

## üèóÔ∏è Arquitectura del Sistema

### **Frontend (Next.js + React)**

#### **1. P√°gina Principal**

**Archivo:** `apps/web/src/app/dashboard/gastos-comunes/page.tsx`

```typescript
// Estructura de la p√°gina principal
export default function GastosComunesPage() {
  const { currentCommunity, communities, isLoading: communitiesLoading } = useCommunity();
  const { user } = useAuth();
  const [isConfigModalOpen, setIsConfigModalOpen] = useState(false);
  const [configModalType, setConfigModalType] = useState<'expenses' | 'income'>('expenses');

  return (
    <ProtectedRoute>
      <RoleGuard allowedRoles={['SUPER_ADMIN', 'COMMUNITY_ADMIN', 'RESIDENT']}>
        <DashboardLayout>
          <CommonExpensesDashboard
            communityId={currentCommunity.id}
            onConfigExpenses={() => {
              setConfigModalType('expenses');
              setIsConfigModalOpen(true);
            }}
            onConfigIncome={() => {
              setConfigModalType('income');
              setIsConfigModalOpen(true);
            }}
          />
          <ExpenseConfigModal
            key={`${configModalType}-${currentCommunity.id}`}
            isOpen={isConfigModalOpen}
            onClose={() => {
              setIsConfigModalOpen(false);
              invalidateExpenseCache(currentCommunity.id);
            }}
            communityId={currentCommunity.id}
            type={configModalType}
          />
        </DashboardLayout>
      </RoleGuard>
    </ProtectedRoute>
  );
}
```

#### **2. Componentes Principales**

##### **A. CommonExpensesDashboard**

**Archivo:** `apps/web/src/components/common-expenses/CommonExpensesDashboard.tsx`

**Responsabilidades:**

- Dashboard principal con estad√≠sticas globales
- Cards de resumen financiero (Total Egresos, Total Ingresos, Balance)
- Integraci√≥n con `MonthlyExpensesTableConnected`
- Manejo de datos de m√∫ltiples servicios

**Caracter√≠sticas Clave:**

```typescript
// Fetch de datos paralelo
const [expensesData, incomesData] = await Promise.all([
  CommonExpenseService.getCommonExpensesByCommunity(communityId),
  CommunityIncomeService.getCommunityIncomes(communityId),
]);

// C√°lculo de estad√≠sticas
const expenseStats = expenses.reduce(
  (acc, expense) => {
    const amount = Number(expense.totalAmount) || 0;
    acc.totalExpenses += amount;
    return acc;
  },
  { totalExpenses: 0 },
);

const incomeStats = incomes.reduce(
  (acc, income) => {
    const amount = Number(income.totalAmount) || 0;
    acc.totalIncome += amount;
    return acc;
  },
  { totalIncome: 0 },
);

const balance = incomeStats.totalIncome - expenseStats.totalExpenses;
```

##### **B. MonthlyExpensesTableConnected**

**Archivo:** `apps/web/src/components/common-expenses/MonthlyExpensesTableConnected.tsx`

**Responsabilidades:**

- Tabla unificada para mostrar egresos e ingresos
- Selector de tipo (Egresos/Ingresos)
- Botones de configuraci√≥n espec√≠ficos por tipo
- Manejo de valores editables con guardado autom√°tico
- Integraci√≥n con hooks de datos

**Caracter√≠sticas Clave:**

```typescript
// Estado del tipo de tabla
const [expenseType, setExpenseType] = useState<"expenses" | "income">(
  "expenses",
);

// Funci√≥n para aplanar items de ingresos
const flattenIncomeItems = useCallback(() => {
  if (expenseType !== "income") return [];

  const flattenedItems: any[] = [];
  incomes.forEach((income) => {
    if (income.items) {
      income.items.forEach((item) => {
        flattenedItems.push({
          id: item.id,
          title: item.name,
          name: item.name,
          amount: item.amount,
          description: item.description,
          categoryId: item.categoryId,
          createdAt: item.createdAt,
          updatedAt: item.updatedAt,
        });
      });
    }
  });
  return flattenedItems;
}, [expenseType, incomes]);

// L√≥gica de guardado diferenciada por tipo
const handleSave = async () => {
  if (expenseType === "expenses") {
    // L√≥gica para gastos comunes (CommonExpensesService)
  } else {
    // L√≥gica para ingresos (CommunityIncomeService)
  }
};
```

##### **C. ExpenseConfigModal**

**Archivo:** `apps/web/src/components/common-expenses/ExpenseConfigModal.tsx`

**Responsabilidades:**

- Modal de configuraci√≥n para categor√≠as e items
- Soporte para ambos tipos: 'expenses' | 'income'
- Gesti√≥n de categor√≠as independientes por tipo
- CRUD completo de items con validaci√≥n

**Caracter√≠sticas Clave:**

```typescript
interface ExpenseConfigModalProps {
  isOpen: boolean;
  onClose: () => void;
  communityId: string;
  onDataChange?: () => void;
  type?: "expenses" | "income"; // Tipo de configuraci√≥n
}

// Carga de categor√≠as filtradas por tipo
const loadCategories = async () => {
  const categoryType = type === "expenses" ? "EXPENSE" : "INCOME";
  const data = await ExpenseCategoriesService.getCategoriesByCommunity(
    communityId,
    categoryType,
  );
  setCategories(data);
};

// Carga de datos seg√∫n tipo
const loadExpenses = async () => {
  if (type === "expenses") {
    const data = await CommonExpensesService.getCommonExpenses(communityId);
    setExpenses(data);
  } else {
    const data = await CommunityIncomeService.getCommunityIncomes(communityId);
    setExpenses(data);
  }
};
```

#### **3. Hooks Personalizados**

##### **A. useExpenseData**

**Archivo:** `apps/web/src/hooks/useExpenseData.tsx`

**Responsabilidades:**

- Gesti√≥n de datos de gastos comunes
- Cache optimizado con TTL
- Transformaci√≥n de datos de API
- Invalidaci√≥n de cache

**Caracter√≠sticas Clave:**

```typescript
// Cache optimizado
const dataCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos

// Funci√≥n de invalidaci√≥n
export const invalidateExpenseCache = (communityId: string) => {
  const cacheKey = `expense-data-${communityId}`;
  dataCache.delete(cacheKey);
};

// Transformaci√≥n de datos
const expensesData = commonExpensesData.flatMap((commonExpense) => {
  return commonExpense.items.map((item) => ({
    id: item.id,
    title: item.name,
    amount: item.amount,
    description: item.description || "",
    categoryId: item.categoryId || "",
    date: commonExpense.dueDate,
    status: "PENDING" as const,
    createdAt: item.createdAt,
  }));
});
```

##### **B. useIncomeData**

**Archivo:** `apps/web/src/hooks/useIncomeData.tsx`

**Responsabilidades:**

- Gesti√≥n de datos de ingresos comunitarios
- Carga de categor√≠as espec√≠ficas de ingresos
- CRUD de ingresos

**Caracter√≠sticas Clave:**

```typescript
const fetchData = useCallback(async () => {
  if (!communityId) return;

  try {
    setIsLoading(true);
    setError(null);

    // Cargar categor√≠as e ingresos en paralelo
    const [categoriesData, incomesData] = await Promise.all([
      ExpenseCategoriesService.getCategoriesByCommunity(communityId, "INCOME"),
      CommunityIncomeService.getCommunityIncomes(communityId),
    ]);

    setCategories(categoriesData);
    setIncomes(incomesData);
  } catch (err) {
    const errorMessage =
      err instanceof Error ? err.message : "Error al cargar los datos";
    setError(errorMessage);
    console.error("Error fetching income data:", err);
  } finally {
    setIsLoading(false);
  }
}, [communityId]);
```

#### **4. Servicios Frontend**

##### **A. CommonExpenseService**

**Archivo:** `apps/web/src/services/commonExpenseService.ts`

**Endpoints:**

- `getCommonExpensesByCommunity(communityId)` - Obtener gastos por comunidad
- `getCommonExpenses(communityId)` - Obtener gastos comunes
- `createCommonExpense(data)` - Crear gasto com√∫n
- `updateCommonExpense(id, data)` - Actualizar gasto com√∫n
- `deleteCommonExpense(id)` - Eliminar gasto com√∫n

##### **B. CommunityIncomeService**

**Archivo:** `apps/web/src/services/communityIncomeService.ts`

**Endpoints:**

- `getCommunityIncomes(communityId)` - Obtener ingresos por comunidad
- `getCommunityIncomeById(id)` - Obtener ingreso espec√≠fico
- `createCommunityIncome(data)` - Crear ingreso comunitario
- `updateCommunityIncome(id, data)` - Actualizar ingreso
- `deleteCommunityIncome(id)` - Eliminar ingreso
- `deleteIncomeItem(incomeId, itemId)` - Eliminar item espec√≠fico

##### **C. ExpenseCategoriesService**

**Archivo:** `apps/web/src/services/api/expense-categories.service.ts`

**Endpoints:**

- `getCategoriesByCommunity(communityId, type?)` - Obtener categor√≠as por comunidad y tipo
- `createCategory(data)` - Crear categor√≠a
- `updateCategory(id, data)` - Actualizar categor√≠a
- `deleteCategory(id)` - Eliminar categor√≠a

---

## üóÑÔ∏è Backend (NestJS + Prisma)

### **1. Estructura de M√≥dulos**

#### **A. CommonExpensesModule**

**Archivo:** `apps/api/src/common-expenses/common-expenses.module.ts`

```typescript
@Module({
  imports: [PrismaModule],
  controllers: [CommonExpensesController],
  providers: [CommonExpensesService],
  exports: [CommonExpensesService],
})
export class CommonExpensesModule {}
```

#### **B. CommunityIncomeModule**

**Archivo:** `apps/api/src/community-income/community-income.module.ts`

```typescript
@Module({
  imports: [PrismaModule],
  controllers: [CommunityIncomeController],
  providers: [CommunityIncomeService],
  exports: [CommunityIncomeService],
})
export class CommunityIncomeModule {}
```

#### **C. ExpenseCategoriesModule**

**Archivo:** `apps/api/src/expense-categories/expense-categories.module.ts`

```typescript
@Module({
  imports: [PrismaModule],
  controllers: [ExpenseCategoriesController],
  providers: [ExpenseCategoriesService],
  exports: [ExpenseCategoriesService],
})
export class ExpenseCategoriesModule {}
```

### **2. Modelos de Base de Datos**

#### **A. CommunityExpense (Egresos)**

```prisma
model CommunityExpense {
  id             String                 @id @default(cuid())
  communityId    String                 @map("community_id")
  period         String
  totalAmount    Decimal                @map("total_amount") @db.Decimal(10, 2)
  dueDate        DateTime               @map("due_date")
  createdAt      DateTime               @default(now()) @map("created_at")
  updatedAt      DateTime               @updatedAt @map("updated_at")
  prorrateMethod ProrrateMethod         @default(EQUAL) @map("prorrate_method")
  items          CommunityExpenseItem[]
  community      Community              @relation(fields: [communityId], references: [id])
  expenses       Expense[]

  @@unique([communityId, period])
  @@index([communityId])
  @@index([period])
  @@map("community_expenses")
}
```

#### **B. CommunityIncome (Ingresos)**

```prisma
model CommunityIncome {
  id             String                @id @default(cuid())
  communityId    String                @map("community_id")
  period         String
  totalAmount    Decimal               @map("total_amount") @db.Decimal(10, 2)
  dueDate        DateTime              @map("due_date")
  createdAt      DateTime              @default(now()) @map("created_at")
  updatedAt      DateTime              @updatedAt @map("updated_at")
  prorrateMethod ProrrateMethod        @default(EQUAL) @map("prorrate_method")
  community      Community             @relation(fields: [communityId], references: [id], onDelete: Cascade)
  items          CommunityIncomeItem[]

  @@unique([communityId, period])
  @@index([communityId])
  @@index([period])
  @@map("community_income")
}
```

#### **C. ExpenseCategory (Categor√≠as)**

```prisma
model ExpenseCategory {
  id          String   @id @default(cuid())
  communityId String   @map("community_id")
  name        String
  description String?
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  type        ExpenseType @default(EXPENSE) @map("type")
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([communityId, name, type])
  @@index([type])
  @@map("expense_categories")
}

enum ExpenseType {
  EXPENSE
  INCOME
}
```

### **3. Servicios Backend**

#### **A. CommonExpensesService**

**Archivo:** `apps/api/src/common-expenses/common-expenses.service.ts`

**M√©todos Principales:**

- `createCommonExpense(user, dto)` - Crear gasto com√∫n con prorrateo
- `getCommonExpensesByCommunity(communityId)` - Obtener gastos por comunidad
- `updateCommonExpense(id, dto)` - Actualizar gasto com√∫n
- `deleteCommonExpense(id)` - Eliminar gasto com√∫n

**Caracter√≠sticas Clave:**

```typescript
// Creaci√≥n con prorrateo autom√°tico
const result = await this.prisma.$transaction(async (prisma) => {
  const createdCommonExpense = await prisma.communityExpense.create({
    data: {
      communityId: dto.communityId,
      period: dto.period,
      totalAmount: totalAmount,
      dueDate: dto.dueDate,
      prorrateMethod: dto.prorrateMethod,
      items: {
        createMany: {
          data: dto.items.map((item) => ({
            name: item.name,
            amount: item.amount,
            description: item.description,
            categoryId: item.categoryId,
          })),
        },
      },
    },
    include: {
      items: true,
    },
  });

  // Crear gastos individuales por unidad
  const expenseData = unitExpenses.map((ue) => ({
    unitId: ue.unitId,
    amount: ue.amount,
    concept: ue.concept,
    description: ue.description,
    dueDate: ue.dueDate,
    status: ue.status,
    communityExpenseId: createdCommonExpense.id,
  }));

  await prisma.expense.createMany({
    data: expenseData,
  });

  return { createdCommonExpense, createdUnitExpenses };
});
```

#### **B. CommunityIncomeService**

**Archivo:** `apps/api/src/community-income/community-income.service.ts`

**M√©todos Principales:**

- `createCommunityIncome(user, dto)` - Crear ingreso comunitario
- `getCommunityIncomes(communityId)` - Obtener ingresos por comunidad
- `updateCommunityIncome(id, dto)` - Actualizar ingreso
- `deleteIncomeItem(incomeId, itemId)` - Eliminar item espec√≠fico

**Caracter√≠sticas Clave:**

```typescript
// Actualizaci√≥n de items individuales
async updateCommunityIncome(id: string, dto: UpdateCommunityIncomeDto) {
  const existingIncome = await this.prisma.communityIncome.findUnique({
    where: { id },
    include: { items: true },
  });

  if (!existingIncome) {
    throw new NotFoundException('Ingreso comunitario no encontrado');
  }

  // Actualizar items existentes y crear nuevos
  const updatedItems = await Promise.all(
    dto.items.map(async (itemDto) => {
      if (itemDto.id) {
        // Actualizar item existente
        return this.prisma.communityIncomeItem.update({
          where: { id: itemDto.id },
          data: {
            name: itemDto.name,
            amount: itemDto.amount,
            description: itemDto.description,
            categoryId: itemDto.categoryId,
          },
        });
      } else {
        // Crear nuevo item
        return this.prisma.communityIncomeItem.create({
          data: {
            communityIncomeId: id,
            name: itemDto.name,
            amount: itemDto.amount,
            description: itemDto.description,
            categoryId: itemDto.categoryId,
          },
        });
      }
    })
  );

  // Recalcular total
  const newTotalAmount = updatedItems.reduce((sum, item) => sum + Number(item.amount), 0);

  return this.prisma.communityIncome.update({
    where: { id },
    data: {
      totalAmount: newTotalAmount,
    },
    include: {
      items: {
        include: {
          category: true,
        },
      },
    },
  });
}
```

#### **C. ExpenseCategoriesService**

**Archivo:** `apps/api/src/expense-categories/expense-categories.service.ts`

**M√©todos Principales:**

- `getCategoriesByCommunity(communityId, type?)` - Obtener categor√≠as filtradas por tipo
- `createCategory(dto)` - Crear categor√≠a con tipo espec√≠fico
- `updateCategory(id, dto)` - Actualizar categor√≠a
- `deleteCategory(id)` - Eliminar categor√≠a

**Caracter√≠sticas Clave:**

```typescript
// Filtrado por tipo
async getCategoriesByCommunity(communityId: string, type?: 'EXPENSE' | 'INCOME') {
  const whereClause: any = {
    communityId,
    isActive: true,
  };

  if (type) {
    whereClause.type = type;
  }

  return this.prisma.expenseCategory.findMany({
    where: whereClause,
    orderBy: { name: 'asc' },
  });
}

// Creaci√≥n con tipo espec√≠fico
async createCategory(dto: CreateExpenseCategoryDto) {
  // Verificar unicidad por tipo
  const existingCategory = await this.prisma.expenseCategory.findFirst({
    where: {
      communityId: dto.communityId,
      name: dto.name,
      type: dto.type || 'EXPENSE',
    },
  });

  if (existingCategory) {
    throw new ConflictException('Ya existe una categor√≠a con este nombre para este tipo');
  }

  return this.prisma.expenseCategory.create({
    data: {
      communityId: dto.communityId,
      name: dto.name,
      description: dto.description,
      type: dto.type || 'EXPENSE',
    },
  });
}
```

### **4. Controladores**

#### **A. CommonExpensesController**

**Archivo:** `apps/api/src/common-expenses/common-expenses.controller.ts`

**Endpoints:**

- `GET /common-expenses/test` - Test endpoint
- `GET /common-expenses/community/:communityId` - Obtener gastos por comunidad
- `POST /common-expenses` - Crear gasto com√∫n
- `PUT /common-expenses/:id` - Actualizar gasto com√∫n
- `DELETE /common-expenses/:id` - Eliminar gasto com√∫n

#### **B. CommunityIncomeController**

**Archivo:** `apps/api/src/community-income/community-income.controller.ts`

**Endpoints:**

- `GET /community-income/community/:communityId` - Obtener ingresos por comunidad
- `GET /community-income/:id` - Obtener ingreso espec√≠fico
- `POST /community-income` - Crear ingreso comunitario
- `PUT /community-income/:id` - Actualizar ingreso
- `DELETE /community-income/:id` - Eliminar ingreso
- `DELETE /community-income/:id/items/:itemId` - Eliminar item espec√≠fico

#### **C. ExpenseCategoriesController**

**Archivo:** `apps/api/src/expense-categories/expense-categories.controller.ts`

**Endpoints:**

- `GET /expense-categories/community/:communityId` - Obtener categor√≠as por comunidad
- `POST /expense-categories` - Crear categor√≠a
- `PUT /expense-categories/:id` - Actualizar categor√≠a
- `DELETE /expense-categories/:id` - Eliminar categor√≠a

---

## üîÑ Flujo de Datos

### **1. Flujo de Creaci√≥n de Gastos Comunes**

```mermaid
graph TD
    A[Usuario crea gasto com√∫n] --> B[ExpenseConfigModal]
    B --> C[CommonExpensesService.createCommonExpense]
    C --> D[Prisma Transaction]
    D --> E[Crear CommunityExpense]
    D --> F[Crear CommunityExpenseItems]
    D --> G[Calcular prorrateo por unidad]
    D --> H[Crear Expenses individuales]
    H --> I[EventBus: EXPENSE_CREATED]
    I --> J[useExpenseData.refreshData]
    J --> K[Actualizar tabla]
```

### **2. Flujo de Creaci√≥n de Ingresos**

```mermaid
graph TD
    A[Usuario crea ingreso] --> B[ExpenseConfigModal type='income']
    B --> C[CommunityIncomeService.createCommunityIncome]
    C --> D[Prisma Transaction]
    D --> E[Crear CommunityIncome]
    D --> F[Crear CommunityIncomeItems]
    D --> G[Calcular prorrateo por unidad]
    D --> H[Crear Expenses individuales]
    H --> I[EventBus: INCOME_CREATED]
    I --> J[useIncomeData.refreshData]
    J --> K[Actualizar tabla]
```

### **3. Flujo de Actualizaci√≥n de Valores**

```mermaid
graph TD
    A[Usuario edita valor en tabla] --> B[MonthlyExpensesTableConnected]
    B --> C[handleSave]
    C --> D{Tipo de tabla?}
    D -->|expenses| E[CommonExpensesService.updateCommonExpense]
    D -->|income| F[CommunityIncomeService.updateCommunityIncome]
    E --> G[Actualizar CommunityExpenseItems]
    F --> H[Actualizar CommunityIncomeItems]
    G --> I[handleDataChange]
    H --> I
    I --> J[Actualizar tabla sin recarga]
```

---

## üé® Sistema de Dise√±o

### **1. Componentes Base**

#### **A. StatCard**

```typescript
interface StatCardProps {
  title: string;
  value: string | number;
  icon: React.ReactNode;
  color?: "blue" | "green" | "red" | "yellow" | "purple";
  trend?: {
    value: number;
    isPositive: boolean;
  };
}
```

#### **B. LoadingSpinner**

```typescript
interface LoadingSpinnerProps {
  size?: "sm" | "md" | "lg";
  text?: string;
  className?: string;
}
```

#### **C. Toast**

```typescript
interface ToastProps {
  message: string;
  type: "success" | "error" | "warning" | "info";
  duration?: number;
}
```

### **2. Sistema de Colores**

```css
/* Colores tem√°ticos */
--blue-50: #eff6ff;
--blue-600: #2563eb;
--green-50: #f0fdf4;
--green-600: #16a34a;
--red-50: #fef2f2;
--red-600: #dc2626;
--yellow-50: #fefce8;
--yellow-600: #ca8a04;
--purple-50: #faf5ff;
--purple-600: #9333ea;
```

### **3. Estados de la Interfaz**

#### **A. Estados de Carga**

- **Loading**: Spinner con mensaje contextual
- **Empty State**: Estado vac√≠o con iconos y acciones
- **Error State**: Manejo de errores con opciones de reintento
- **Success State**: Confirmaciones visuales de acciones

#### **B. Estados Interactivos**

- **Hover**: Efectos de profundidad y transiciones suaves
- **Focus**: Estados de enfoque accesibles
- **Disabled**: Estados deshabilitados claros
- **Active**: Estados activos diferenciados

---

## üîß Patrones de Desarrollo

### **1. Patr√≥n de Hooks Personalizados**

```typescript
// Estructura est√°ndar de hooks
export function useCustomData(communityId: string) {
  const [data, setData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    if (!communityId) return;

    try {
      setIsLoading(true);
      setError(null);

      const result = await Service.getData(communityId);
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error desconocido");
    } finally {
      setIsLoading(false);
    }
  }, [communityId]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    isLoading,
    error,
    refetch: fetchData,
  };
}
```

### **2. Patr√≥n de Servicios Frontend**

```typescript
// Estructura est√°ndar de servicios
export class CustomService {
  private static baseUrl = "/api/custom";

  static async getData(id: string): Promise<DataType[]> {
    try {
      console.log("üîç [CustomService] getData - id:", id);
      const response = await apiClient.get(`${this.baseUrl}/${id}`);
      console.log("‚úÖ [CustomService] getData - success:", response.data);
      return response.data;
    } catch (error) {
      console.error("‚ùå [CustomService] getData - error:", error);
      throw error;
    }
  }

  static async createData(data: CreateDataType): Promise<DataType> {
    try {
      console.log("üîç [CustomService] createData - data:", data);
      const response = await apiClient.post(this.baseUrl, data);
      console.log("‚úÖ [CustomService] createData - success:", response.data);
      return response.data;
    } catch (error) {
      console.error("‚ùå [CustomService] createData - error:", error);
      throw error;
    }
  }
}
```

### **3. Patr√≥n de Componentes Modales**

```typescript
// Estructura est√°ndar de modales
interface CustomModalProps {
  isOpen: boolean;
  onClose: () => void;
  communityId: string;
  onDataChange?: () => void;
  type?: 'type1' | 'type2';
}

export default function CustomModal({
  isOpen,
  onClose,
  communityId,
  onDataChange,
  type = 'type1',
}: CustomModalProps) {
  const [data, setData] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const { showToast } = useToast();

  // Cargar datos al abrir o cambiar tipo
  useEffect(() => {
    if (isOpen) {
      loadData();
    }
  }, [isOpen, type, communityId]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      const result = await Service.getData(communityId, type);
      setData(result);
    } catch (error) {
      showToast('Error al cargar datos', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      {/* Contenido del modal */}
    </Modal>
  );
}
```

### **4. Patr√≥n de Manejo de Estados**

```typescript
// Estados est√°ndar para componentes complejos
const [data, setData] = useState([]);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [editingId, setEditingId] = useState<string | null>(null);
const [formData, setFormData] = useState(initialFormData);
const [errors, setErrors] = useState<Record<string, string>>({});
const [isSaving, setIsSaving] = useState(false);
```

---

## üöÄ Mejores Pr√°cticas

### **1. Gesti√≥n de Estado**

#### **‚úÖ Hacer:**

- Usar hooks personalizados para l√≥gica compleja
- Implementar cache con TTL para optimizar rendimiento
- Usar `useCallback` y `useMemo` para optimizar re-renders
- Implementar invalidaci√≥n de cache cuando sea necesario

#### **‚ùå No hacer:**

- Manejar estado complejo directamente en componentes
- Hacer llamadas a API sin cache
- Olvidar limpiar efectos secundarios
- No manejar estados de error

### **2. Manejo de Datos**

#### **‚úÖ Hacer:**

- Transformar datos de API en el hook, no en el componente
- Usar tipos TypeScript estrictos
- Implementar validaci√≥n de datos
- Manejar casos edge (datos vac√≠os, errores de red)

#### **‚ùå No hacer:**

- Transformar datos en m√∫ltiples lugares
- Usar `any` para tipos
- Ignorar validaci√≥n de datos
- No manejar casos de error

### **3. Componentes**

#### **‚úÖ Hacer:**

- Separar l√≥gica de presentaci√≥n
- Usar props tipadas
- Implementar estados de carga y error
- Hacer componentes reutilizables

#### **‚ùå No hacer:**

- Mezclar l√≥gica de negocio con presentaci√≥n
- Usar props no tipadas
- Ignorar estados de carga
- Crear componentes muy espec√≠ficos

### **4. API y Backend**

#### **‚úÖ Hacer:**

- Usar transacciones para operaciones complejas
- Implementar validaci√≥n de DTOs
- Usar decoradores de autorizaci√≥n
- Manejar errores apropiadamente

#### **‚ùå No hacer:**

- Hacer operaciones sin transacciones
- Saltarse validaci√≥n de datos
- Ignorar autorizaci√≥n
- No manejar errores de base de datos

---

## üîç Debugging y Logging

### **1. Logging Frontend**

```typescript
// Patr√≥n est√°ndar de logging
console.log("üîç [ComponentName] action - params:", params);
console.log("‚úÖ [ComponentName] action - success:", result);
console.error("‚ùå [ComponentName] action - error:", error);

// Ejemplos espec√≠ficos
console.log("üìä Inicializando datos - expenseType:", expenseType);
console.log("üí∞ Items de ingresos aplanados:", itemsToProcess.length);
console.log("üîÑ Refrescando datos para", communityId);
```

### **2. Logging Backend**

```typescript
// Patr√≥n est√°ndar de logging en servicios
console.log("üîç [ServiceName] method - params:", params);
console.log("‚úÖ [ServiceName] method - success");
console.error("‚ùå [ServiceName] method - error:", error);

// Ejemplos espec√≠ficos
console.log("üîç [CommonExpensesService] createCommonExpense - dto:", dto);
console.log("‚úÖ [CommonExpensesService] createCommonExpense - success");
console.error("‚ùå [CommonExpensesService] createCommonExpense - error:", error);
```

### **3. Debugging de Estados**

```typescript
// Debug de estados complejos
useEffect(() => {
  console.log("üìä Estado actual:", {
    expenseType,
    categories: categories.length,
    expenses: expenses.length,
    incomes: incomes.length,
    isLoading,
    error,
  });
}, [expenseType, categories, expenses, incomes, isLoading, error]);
```

---

## üìù Checklist de Desarrollo

### **Al Crear un Nuevo Componente:**

- [ ] ¬øEst√° tipado correctamente con TypeScript?
- [ ] ¬øManeja estados de carga y error?
- [ ] ¬øEs reutilizable y configurable?
- [ ] ¬øTiene logging apropiado?
- [ ] ¬øSigue el patr√≥n de dise√±o establecido?

### **Al Crear un Nuevo Hook:**

- [ ] ¬øManeja cache apropiadamente?
- [ ] ¬øTiene invalidaci√≥n de cache?
- [ ] ¬øManeja errores correctamente?
- [ ] ¬øEs optimizado con useCallback/useMemo?
- [ ] ¬øTiene logging de debugging?

### **Al Crear un Nuevo Servicio:**

- [ ] ¬øSigue el patr√≥n de logging establecido?
- [ ] ¬øManeja errores de API apropiadamente?
- [ ] ¬øEst√° tipado correctamente?
- [ ] ¬øTiene m√©todos CRUD completos?
- [ ] ¬øEs consistente con otros servicios?

### **Al Crear un Nuevo Endpoint Backend:**

- [ ] ¬øTiene validaci√≥n de DTOs?
- [ ] ¬øUsa decoradores de autorizaci√≥n?
- [ ] ¬øManeja errores apropiadamente?
- [ ] ¬øUsa transacciones cuando es necesario?
- [ ] ¬øTiene logging de debugging?

---

## üéØ Reglas Espec√≠ficas para Cursor

### **1. Al Trabajar con Gastos Comunes:**

- **Siempre** verificar si el componente maneja ambos tipos (`expenses` | `income`)
- **Siempre** usar los hooks apropiados (`useExpenseData` vs `useIncomeData`)
- **Siempre** usar los servicios correctos (`CommonExpenseService` vs `CommunityIncomeService`)
- **Siempre** implementar invalidaci√≥n de cache despu√©s de cambios

### **2. Al Trabajar con la Tabla:**

- **Siempre** usar `flattenIncomeItems()` para datos de ingresos
- **Siempre** diferenciar la l√≥gica de guardado por tipo
- **Siempre** mantener el estado de edici√≥n correctamente
- **Siempre** emitir eventos apropiados para actualizaciones

### **3. Al Trabajar con Modales:**

- **Siempre** pasar el `type` prop correctamente
- **Siempre** usar `key` prop para forzar re-render cuando cambie el tipo
- **Siempre** cargar datos espec√≠ficos por tipo
- **Siempre** manejar estados de carga y error

### **4. Al Trabajar con Backend:**

- **Siempre** usar transacciones para operaciones complejas
- **Siempre** validar DTOs con decoradores apropiados
- **Siempre** manejar casos de error con excepciones apropiadas
- **Siempre** usar logging consistente

### **5. Al Trabajar con Base de Datos:**

- **Siempre** usar el campo `type` en `ExpenseCategory` para diferenciar tipos
- **Siempre** mantener relaciones correctas entre modelos
- **Siempre** usar √≠ndices apropiados para consultas frecuentes
- **Siempre** manejar cascadas de eliminaci√≥n correctamente

---

## üö® Errores Comunes y Soluciones

### **1. Error: "toFixed is not a function"**

**Causa:** Valor no es n√∫mero
**Soluci√≥n:** Convertir a `Number()` antes de usar `toFixed()`

### **2. Error: "Categories being shared between expenses and incomes"**

**Causa:** No usar el campo `type` en `ExpenseCategory`
**Soluci√≥n:** Filtrar categor√≠as por tipo en el frontend

### **3. Error: "Page reloads when saving income"**

**Causa:** Usar l√≥gica de gastos para ingresos
**Soluci√≥n:** Diferenciar l√≥gica de guardado por tipo

### **4. Error: "Income items not showing individually"**

**Causa:** No usar `flattenIncomeItems()`
**Soluci√≥n:** Aplanar datos de ingresos para mostrar items individuales

### **5. Error: "404 when deleting income item"**

**Causa:** Ruta no existe o orden incorrecto de rutas
**Soluci√≥n:** Verificar que la ruta espec√≠fica est√© antes que la general

---

## üìö Referencias y Recursos

### **Archivos Clave:**

- `apps/web/src/app/dashboard/gastos-comunes/page.tsx` - P√°gina principal
- `apps/web/src/components/common-expenses/CommonExpensesDashboard.tsx` - Dashboard
- `apps/web/src/components/common-expenses/MonthlyExpensesTableConnected.tsx` - Tabla principal
- `apps/web/src/components/common-expenses/ExpenseConfigModal.tsx` - Modal de configuraci√≥n
- `apps/web/src/hooks/useExpenseData.tsx` - Hook de gastos
- `apps/web/src/hooks/useIncomeData.tsx` - Hook de ingresos
- `apps/api/src/common-expenses/` - Backend de gastos
- `apps/api/src/community-income/` - Backend de ingresos
- `apps/api/src/expense-categories/` - Backend de categor√≠as

### **Servicios Frontend:**

- `apps/web/src/services/commonExpenseService.ts`
- `apps/web/src/services/communityIncomeService.ts`
- `apps/web/src/services/api/expense-categories.service.ts`

### **Modelos de Base de Datos:**

- `CommunityExpense` - Gastos comunes
- `CommunityIncome` - Ingresos comunitarios
- `ExpenseCategory` - Categor√≠as (con campo `type`)
- `CommunityExpenseItem` - Items de gastos
- `CommunityIncomeItem` - Items de ingresos

---

**¬°Este m√≥dulo est√° completamente documentado y listo para desarrollo!** üéâ

Sigue estas reglas y patrones para mantener la consistencia y calidad del c√≥digo en el m√≥dulo de Gastos Comunes.
